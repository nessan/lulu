[
  {
    "objectID": "pages/callable/index.html",
    "href": "pages/callable/index.html",
    "title": "Function Arguments in the lulu Library",
    "section": "",
    "text": "Many methods in the lulu library are passed a function as one of their arguments.\nFor example, the lulu.Array class has various search and filter methods that expect to be passed a predicate function that will pick out specific elements in an array.\nIf a is an Array we can use a:take_if to extract elements that satisfy some predicate.\nlocal a = Array{1,0,2,0,0,3}\nlocal non_zero = a:take_if(function(x) return x &gt; 0 end)\nputln(\"%s has non-zero elements %s\", a, non_zero)\nThis will output [1, 0, 2, 0, 0, 3] has non-zero elements [1, 2, 3] where we are using the Scribe module for easy formatted output printing.\nSimilarly, we have mapping and transformation functions like:\nlocal a = Array{1,0,2,0,0,3}\nlocal b = a:map(function(x) return 2*x end)\nputln(\"%s doubles to %s\", a, b)\nThis outputs [1, 0, 2, 0, 0, 3] doubles to [2, 0, 4, 0, 0, 6].\nAs shown, these methods are happy to be passed complete Lua function definitions, which allow you to do arbitrarily complex things. However, the arguments to higher-order functions like these are often quite simple, so we also support the idea of functions as string operators and string lambdas—anonymous functions, if you will.\nThe first example above can be written in a simpler and more readily understood form:\nlocal a = Array{1,0,2,0,0,3}\nlocal non_zero = a:take_if(\"&gt;\", 0)\nputln(\"%s has non-zero elements %s\", a, non_zero)\nThe second becomes:\nlocal a = Array{1,0,2,0,0,3}\nlocal b = a:map(\"|x| 2*x\")\nputln(\"%s doubles to %s\", a, b)\nOr even more, simply using anonymous arguments (i.e. using _ in place of the named argument x)\nlocal a = Array{1,0,2,0,0,3}\nlocal b = a:map(\"2 * _\")\nputln(\"%s doubles to %s\", a, b)",
    "crumbs": [
      "Home",
      "Anonymous Functions"
    ]
  },
  {
    "objectID": "pages/callable/index.html#introduction",
    "href": "pages/callable/index.html#introduction",
    "title": "Function Arguments in the lulu Library",
    "section": "",
    "text": "Many methods in the lulu library are passed a function as one of their arguments.\nFor example, the lulu.Array class has various search and filter methods that expect to be passed a predicate function that will pick out specific elements in an array.\nIf a is an Array we can use a:take_if to extract elements that satisfy some predicate.\nlocal a = Array{1,0,2,0,0,3}\nlocal non_zero = a:take_if(function(x) return x &gt; 0 end)\nputln(\"%s has non-zero elements %s\", a, non_zero)\nThis will output [1, 0, 2, 0, 0, 3] has non-zero elements [1, 2, 3] where we are using the Scribe module for easy formatted output printing.\nSimilarly, we have mapping and transformation functions like:\nlocal a = Array{1,0,2,0,0,3}\nlocal b = a:map(function(x) return 2*x end)\nputln(\"%s doubles to %s\", a, b)\nThis outputs [1, 0, 2, 0, 0, 3] doubles to [2, 0, 4, 0, 0, 6].\nAs shown, these methods are happy to be passed complete Lua function definitions, which allow you to do arbitrarily complex things. However, the arguments to higher-order functions like these are often quite simple, so we also support the idea of functions as string operators and string lambdas—anonymous functions, if you will.\nThe first example above can be written in a simpler and more readily understood form:\nlocal a = Array{1,0,2,0,0,3}\nlocal non_zero = a:take_if(\"&gt;\", 0)\nputln(\"%s has non-zero elements %s\", a, non_zero)\nThe second becomes:\nlocal a = Array{1,0,2,0,0,3}\nlocal b = a:map(\"|x| 2*x\")\nputln(\"%s doubles to %s\", a, b)\nOr even more, simply using anonymous arguments (i.e. using _ in place of the named argument x)\nlocal a = Array{1,0,2,0,0,3}\nlocal b = a:map(\"2 * _\")\nputln(\"%s doubles to %s\", a, b)",
    "crumbs": [
      "Home",
      "Anonymous Functions"
    ]
  },
  {
    "objectID": "pages/callable/index.html#module-methods-and-data",
    "href": "pages/callable/index.html#module-methods-and-data",
    "title": "Function Arguments in the lulu Library",
    "section": "Module Methods and Data",
    "text": "Module Methods and Data\nIf you have imported the module as\nlocal callable = require 'lulu.callable'\nYou have access to the following methods.\ncallable.from(fun, fatal_on_error)  This is the master method that tries to return a Lua function from the fun argument, which can be:\n\nAl Lua function.\nA callable object like a table with a __call(...) metamethod.\nA string that we can interpret as a lambda function.\nA string that we can interpret as a standard Lua operator.\n\nIf the optional boolean fatal_on_error argument is true (which it is by default), then we raise a fatal error if fun cannot be interpreted as a function.\n\n    \n     \n    \n    \nThe simple function call callable(fun) is identical to callable.from(fun).\n\ncallable.is_callable(fun)  Returns true if the fun argument will return a Lua function when passed to callable.from(fun). callable[op] \nThe callable module also maps standard operator “names” to their definition in the form of a Lua function.\n\n\n\n\n\n\n\n\nKey\nCorresponding Lua Function\n\n\n\n\ncallable['+']\nfunction(a,b) return a + b end,\n\n\ncallable['-']\nfunction(a,b) return a - b end,\n\n\ncallable['*']\nfunction(a,b) return a * b end,\n\n\ncallable['/']\nfunction(a,b) return a / b end,\n\n\ncallable['%']\nfunction(a,b) return a % b end,\n\n\ncallable['^']\nfunction(a,b) return a ^ b end,\n\n\ncallable['==']\nfunction(a,b) return a == b end,\n\n\ncallable['~=']\nfunction(a,b) return a ~= b end,\n\n\ncallable['&lt;']\nfunction(a,b) return a &lt; b end,\n\n\ncallable['&lt;=']\nfunction(a,b) return a &lt;= b end,\n\n\ncallable['&gt;']\nfunction(a,b) return a &gt; b end,\n\n\ncallable['&gt;=']\nfunction(a,b) return a &gt;= b end,\n\n\ncallable['and']\nfunction(a,b) return a and b end,\n\n\ncallable['or']\nfunction(a,b) return a or b end,\n\n\ncallable['()']\nfunction(fn, ...) return fn(...) end,\n\n\ncallable['{}']\nfunction(...) return {...} end,\n\n\ncallable['[]']\nfunction(t, k) return t[k] end,\n\n\ncallable['#']\nfunction(a) return #a end,\n\n\ncallable['..']\nfunction(a,b) return a .. b end,\n\n\ncallable['~']\nfunction(a,b) return string.find(a, b) ~= nil end,\n\n\ncallable['']\nfunction(...) return ... end\n\n\n\n\nWe had the example above a:take_if(\"&gt;\", 0). The take_if signature is take_if(fun, ...) and that call works as follows:\n\nThe callable module looks up that first string argument “&gt;” in its table and finds a corresponding value function(x,y) return x &gt; y end, a function of two arguments x and y.\nThen take_if calls that function as fun(a[i], ...) iterating through the elements of a for the first argument and passing any trailing arguments it received after that. There was just one of those — the number 0.\n\n\n    \n     \n    \n    \nYou can call Lua functions with many more arguments than they expect and those are just ignored.\n\ncallable.lambda(str, issue_warnings)  This tries to create a Lua function using either named or anonymous arguments from a lambda string.\nIf the optional boolean issue_warnings argument is true (which it is by default), then we issue a warning if fun cannot be interpreted as a function and then return nil.\nThe syntax used is similar to that from other languages like Rust: |args| body or body with _ marking a single argument.",
    "crumbs": [
      "Home",
      "Anonymous Functions"
    ]
  },
  {
    "objectID": "pages/callable/index.html#examples",
    "href": "pages/callable/index.html#examples",
    "title": "Function Arguments in the lulu Library",
    "section": "Examples",
    "text": "Examples\nlocal f = callable.lambda(\"|a| a + 1\")\nlocal g = callable.lambda(\"|a,b| a * b\")\nlocal h = callable.lambda(\"_ + 1\")\nprint(f(10), g(10,11), h(10))\nOutputs 11 110 11 as expected.\n\n    \n     \n    \n    \nThe shorthand callable(\"|a| a + 1\") will return the same function as callable.lambda(\"|a| a + 1\")\n\n\n\n\n\n\n\n\nString\nLua Function\n\n\n\n\n|a| a + 1\nfunction(a) return a + 1 end\n\n\n|a, b| a * b\nfunction(a, b) return a * b end\n\n\n_ + 1\nfunction(_) return _ + 1 end",
    "crumbs": [
      "Home",
      "Anonymous Functions"
    ]
  },
  {
    "objectID": "pages/callable/index.html#acknowledgement",
    "href": "pages/callable/index.html#acknowledgement",
    "title": "Function Arguments in the lulu Library",
    "section": "Acknowledgement",
    "text": "Acknowledgement\nLike many items in the lulu library, this was inspired by Penlight.",
    "crumbs": [
      "Home",
      "Anonymous Functions"
    ]
  },
  {
    "objectID": "pages/callable/index.html#see-also",
    "href": "pages/callable/index.html#see-also",
    "title": "Function Arguments in the lulu Library",
    "section": "See Also",
    "text": "See Also\nlulu.table  lulu.string  lulu.Array",
    "crumbs": [
      "Home",
      "Anonymous Functions"
    ]
  },
  {
    "objectID": "pages/Array/search.html",
    "href": "pages/Array/search.html",
    "title": "Lulu Arrays — Searches",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you can use the following methods:\nArray:all(predicate,...)  Returns true if all of the elements from self pass a predicate test.\nArray:any(predicate,...)  Returns true if any element from self passes a predicate test.\nArray:none(predicate,...)  Returns true if none of the elements from self passes a predicate test.\nArray:find(value ,start_index)  Returns the index of the first element that matches value or nil if the search fails.\nArray:find_reverse(value ,start_index)  Returns the index of the first element that matches value or nil if the search fails.  The search is done in reverse, starting from the end of self.\nArray:find_if(predicate, start_index,...)  Returns the index of the first element that satisfies a predicate or nil if that is not found.\nArray:fin_if_reverse(predicate, start_index,...)  Returns the index of the first element that satisfies a predicate or nil if that is not found.  The search is done in reverse, starting from the end of self.\n\n    \n     \n    \n    \nThe start_index argument is optional. It sets the index where we start our searches. By default, we begin at the beginning of the array for regular searches, while the default for reverse searches is at the end. A negative start_index means starting at a spot from the end of the array for regular searches and from the start for reverse searches. You can use the start_index argument to iterate through multiple matches to value in the array."
  },
  {
    "objectID": "pages/Array/search.html#introduction",
    "href": "pages/Array/search.html#introduction",
    "title": "Lulu Arrays — Searches",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you can use the following methods:\nArray:all(predicate,...)  Returns true if all of the elements from self pass a predicate test.\nArray:any(predicate,...)  Returns true if any element from self passes a predicate test.\nArray:none(predicate,...)  Returns true if none of the elements from self passes a predicate test.\nArray:find(value ,start_index)  Returns the index of the first element that matches value or nil if the search fails.\nArray:find_reverse(value ,start_index)  Returns the index of the first element that matches value or nil if the search fails.  The search is done in reverse, starting from the end of self.\nArray:find_if(predicate, start_index,...)  Returns the index of the first element that satisfies a predicate or nil if that is not found.\nArray:fin_if_reverse(predicate, start_index,...)  Returns the index of the first element that satisfies a predicate or nil if that is not found.  The search is done in reverse, starting from the end of self.\n\n    \n     \n    \n    \nThe start_index argument is optional. It sets the index where we start our searches. By default, we begin at the beginning of the array for regular searches, while the default for reverse searches is at the end. A negative start_index means starting at a spot from the end of the array for regular searches and from the start for reverse searches. You can use the start_index argument to iterate through multiple matches to value in the array."
  },
  {
    "objectID": "pages/Array/search.html#arrayall-arrayany-arraynone",
    "href": "pages/Array/search.html#arrayall-arrayany-arraynone",
    "title": "Lulu Arrays — Searches",
    "section": "Array:all, Array:any, Array:none",
    "text": "Array:all, Array:any, Array:none\nlocal arr =Array:range(-5,5)\nputln(\"arr: %s\", arr)\nputln(\"all  &gt; 0: %s\", arr:all(\"&gt;\", 0))\nputln(\"any  &gt; 0: %s\", arr:any(\"&gt;\", 0))\nputln(\"none &gt; 0: %s\", arr:none(\"&gt;\", 0))\nOutputs:\narr: [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]\nall  &gt; 0: false\nany  &gt; 0: true\nnone &gt; 0: false"
  },
  {
    "objectID": "pages/Array/search.html#arrayfind-arrayfind_reverse",
    "href": "pages/Array/search.html#arrayfind-arrayfind_reverse",
    "title": "Lulu Arrays — Searches",
    "section": "Array:find & Array:find_reverse",
    "text": "Array:find & Array:find_reverse\nThese are the simplest search-for-a-value methods.\nExample: Forward searches\n1local arr = Array{'a', 'b', 'a', 'c', 'b', 'a'}\nputln(\"%t contains a 'c': %s\", arr, arr:has_value('c'))\n\n2local i = arr:find('a')\nwhile i do\n    print(\"Found an 'a' at index:\", i)\n3    i = arr:find('a', i+1)\nend\n\n1\n\nAn Array with repeated values.\n\n2\n\nLook for the first ‘a’ in the array.\n\n3\n\nLook for successive values of ‘a’ starting beyond the last successful search.\n\n\nOutputs:\n[\"a\", \"b\", \"a\", \"c\", \"b\", \"a\"] contains a 'c': true\nFound an 'a' at index:  1\nFound an 'a' at index:  3\nFound an 'a' at index:  6\nExample: Reverse searches\nlocal arr = Array{'a', 'b', 'a', 'c', 'b', 'a'}\nlocal i = arr:find_reverse('a')\nwhile i do\n    print(\"Found an 'a' at index:\", i)\n    i = arr:find_reverse('a', i-1)\nend\nOutputs:\nFound an 'a' at index:  6\nFound an 'a' at index:  3\nFound an 'a' at index:  1"
  },
  {
    "objectID": "pages/Array/search.html#arrayfind_if-arrayfind_if_reverse",
    "href": "pages/Array/search.html#arrayfind_if-arrayfind_if_reverse",
    "title": "Lulu Arrays — Searches",
    "section": "Array:find_if & Array:find_if_reverse",
    "text": "Array:find_if & Array:find_if_reverse\nThese functions find the first index on or after the start_index, where the corresponding value passes a predicate test. They also return the value found and what the predicate evaluated to — though, of course, you are free to ignore those extra outputs if they aren’t helpful.\nExample: Forward predicate search\nlocal arr = Array:range(-5,5)\nlocal i,v = arr:find_if(\"|v| v &gt; 0\")\nwhile i do\n    putln(\"Found the positive value %d at index %d.\", v, i)\n    i,v = arr:find_if(\"|v| v &gt; 0\", i+1)\nend\nOutputs:\nFound the positive value 1 at index 7.\nFound the positive value 2 at index 8.\nFound the positive value 3 at index 9.\nFound the positive value 4 at index 10.\nFound the positive value 5 at index 11.\nExample: Reverse predicate search\nlocal arr = Array:range(-5,5)\nlocal i,v = arr:find_if_reverse(\"|v| v &gt; 0\")\nwhile i do\n    putln(\"Found the positive value %d at index %d.\", v, i)\n    i,v = arr:find_if_reverse(\"|v| v &gt; 0\", i-1)\nend\nOutputs:\nFound the positive value 5 at index 11.\nFound the positive value 4 at index 10.\nFound the positive value 3 at index 9.\nFound the positive value 2 at index 8.\nFound the positive value 1 at index 7."
  },
  {
    "objectID": "pages/Array/search.html#predicate-functions",
    "href": "pages/Array/search.html#predicate-functions",
    "title": "Lulu Arrays — Searches",
    "section": "Predicate Functions",
    "text": "Predicate Functions\nThe predicate function will be called as predicate(arr[i],...) for each element arr[i] in the array arr. It should return true if that element is considered to have passed the test.\nThe function is passed any extra ... arguments that were given to the original class method call. Of course, it may ignore those.\nThe “function” can come in several forms. For example, the predicate to test for positivity can be written as:\n\narr:index_where(function(v) return v &gt; 0 end)\narr:index_where(\"&gt;\", 1, 0)\narr:index_where(\"|v| v &gt; 0\")\nYou can pass a “table” that is callable, i.e., it has a __call() metamethod that does the appropriate thing.\n\nThere is more detail on the second and third options in the documentation for the lulu.callable module.\n\n    \n     \n    \n    \nFor some of these methods, we have an optional start_index that comes before those ... arguments to our predicate. This makes the second string operator option above less desirable."
  },
  {
    "objectID": "pages/Array/search.html#see-also",
    "href": "pages/Array/search.html#see-also",
    "title": "Lulu Arrays — Searches",
    "section": "See Also",
    "text": "See Also\nArray:delete_if  Array:keep_if  Array:take_if  Array:drop_if  lulu.callable"
  },
  {
    "objectID": "pages/Array/union.html",
    "href": "pages/Array/union.html",
    "title": "Lulu Arrays — Unions, Intersections, Differences",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you can use the following methods to combine Arrays:\nArray:union(...)  Returns a new Array that has all the values from the arguments (without any duplicates).  Any non-table argument will be treated as single element array.\nArray:intersection(...)  Returns a new Array that holds the common values from the arguments (without any duplicates).  Any non-table argument will be treated as single element array.\nArray:difference(other, symmetric)  Returns a new Array that holds the elements of self that are not in other where other can be an Array or a plain Lua array.\n\n    \n     \n    \n    \nThese methods only consider each clement’s value when looking for commonality and differences. This contrasts with the table.union, table.intersection and table.difference methods which consider both the element index and the value.\n\nGenerally a:difference(b)  ~= b:difference(a).\nWe sometimes refer to a:difference(b) as \\(a - b\\).\nBy default, the boolean symmetric argument is false. You can set it to true to get the symmetric difference between \\(a\\) and \\(b\\): \\[\na - b \\cup b - a.\n\\] That is the array of the elements that occurs only in one of a or b."
  },
  {
    "objectID": "pages/Array/union.html#introduction",
    "href": "pages/Array/union.html#introduction",
    "title": "Lulu Arrays — Unions, Intersections, Differences",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you can use the following methods to combine Arrays:\nArray:union(...)  Returns a new Array that has all the values from the arguments (without any duplicates).  Any non-table argument will be treated as single element array.\nArray:intersection(...)  Returns a new Array that holds the common values from the arguments (without any duplicates).  Any non-table argument will be treated as single element array.\nArray:difference(other, symmetric)  Returns a new Array that holds the elements of self that are not in other where other can be an Array or a plain Lua array.\n\n    \n     \n    \n    \nThese methods only consider each clement’s value when looking for commonality and differences. This contrasts with the table.union, table.intersection and table.difference methods which consider both the element index and the value.\n\nGenerally a:difference(b)  ~= b:difference(a).\nWe sometimes refer to a:difference(b) as \\(a - b\\).\nBy default, the boolean symmetric argument is false. You can set it to true to get the symmetric difference between \\(a\\) and \\(b\\): \\[\na - b \\cup b - a.\n\\] That is the array of the elements that occurs only in one of a or b."
  },
  {
    "objectID": "pages/Array/union.html#example",
    "href": "pages/Array/union.html#example",
    "title": "Lulu Arrays — Unions, Intersections, Differences",
    "section": "Example",
    "text": "Example\nlocal a1 = Array{1,2,3,4}\nlocal a2 = Array{3,4,5,6}\nputln(\"a1:                          %t\", a1)\nputln(\"a2:                          %t\", a2)\nputln(\"Union         a1,  a2:       %t\", a1:union(a2))\nputln(\"Append        a1,  a2:       %t\", a1:append(a2))\nputln(\"Intersection  a1,  a2:       %t\", a1:intersection(a2))\nputln(\"Difference    a1 - a2:       %t\", a1:difference(a2))\nputln(\"Difference    a2 - a1:       %t\", a2:difference(a1))\nputln(\"Symmetric difference a1, a2: %t\", a1:difference(a2, true))\nputln(\"Symmetric difference a2, a1: %t\", a2:difference(a1, true))\nOutputs:\na1:                          [1, 2, 3, 4]\na2:                          [3, 4, 5, 6]\nUnion         a1,  a2:       [1, 2, 3, 4, 5, 6]\n1Append        a1,  a2:       [1, 2, 3, 4, 3, 4, 5, 6]\nIntersection  a1,  a2:       [3, 4, 5, 6]\nDifference    a1 - a2:       [1, 2]\nDifference    a2 - a1:       []\nSymmetric difference a1, a2: [1, 2]\nSymmetric difference a2, a1: [1, 2]\n\n1\n\nThe Array:append method just appends a2 to a1 which means there is duplication in this example.\n\n\nNow look at the same example using table.union, table.intersection and table.difference.\nlocal a1 = Array{1,2,3,4}\nlocal a2 = Array{3,4,5,6}\nputln(\"a1:                          %t\", a1)\nputln(\"a2:                          %t\", a2)\nputln(\"Union         a1,  a2:       %t\", table.union(a1, a2))\nputln(\"Intersection  a1,  a2:       %t\", table.intersection(a1, a2))\nputln(\"Difference    a1 - a2:       %t\", table.difference(a1, a2))\nputln(\"Difference    a2 - a1:       %t\", table.difference(a2, a1))\nputln(\"Symmetric difference a1, a2: %t\", table.difference(a1, a2, true))\nputln(\"Symmetric difference a1, a2: %t\", table.difference(a2, a1, true))\nOutputs\na1:                          [1, 2, 3, 4]\na2:                          [3, 4, 5, 6]\n1Union         a1,  a2:       {{1, 3}, {2, 4}, {3, 5}, {4, 6}}\n2Intersection  a1,  a2:       {}\nDifference    a1 - a2:       {1, 2, 3, 4}\nDifference    a2 - a1:       {3, 4, 5, 6}\nSymmetric difference a1, a2: {{1, 3}, {2, 4}, {3, 5}, {4, 6}}\nSymmetric difference a1, a2: {{3, 1}, {4, 2}, {5, 3}, {6, 4}}\n\n1\n\nThere are multiple values for the index keys 1,2,3 and 4.\n\n2\n\nThe common values are not at the same index position in the two arrays so the intersection is empty as far as table is concerned."
  },
  {
    "objectID": "pages/Array/union.html#see-also",
    "href": "pages/Array/union.html#see-also",
    "title": "Lulu Arrays — Unions, Intersections, Differences",
    "section": "See Also",
    "text": "See Also\nArray:append  Array.__concat  table.union  table.intersection  table.difference  table.common_values"
  },
  {
    "objectID": "pages/Array/at.html",
    "href": "pages/Array/at.html",
    "title": "Lulu Arrays — Element Retrieval",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen you have access to the following methods:\nArray:first(default)  Returns the first element or an optional default value if self is empty.\nArray:final(default)  Returns the final element or an optional default value if self is empty.\nArray:at(i)  Returns a specific element from self where negative values for i count back from the end of the array.\n\n    \n     \n    \n    \nNo range check is performed on the index i.\n\nArray:random()  Returns a random element from self or nil if the array is empty."
  },
  {
    "objectID": "pages/Array/at.html#introduction",
    "href": "pages/Array/at.html#introduction",
    "title": "Lulu Arrays — Element Retrieval",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen you have access to the following methods:\nArray:first(default)  Returns the first element or an optional default value if self is empty.\nArray:final(default)  Returns the final element or an optional default value if self is empty.\nArray:at(i)  Returns a specific element from self where negative values for i count back from the end of the array.\n\n    \n     \n    \n    \nNo range check is performed on the index i.\n\nArray:random()  Returns a random element from self or nil if the array is empty."
  },
  {
    "objectID": "pages/Array/at.html#arrayfirst-arrayfinal",
    "href": "pages/Array/at.html#arrayfirst-arrayfinal",
    "title": "Lulu Arrays — Element Retrieval",
    "section": "Array:first & Array:final",
    "text": "Array:first & Array:final\nExample:\nlocal arr = Array:range(1,10)\nputln(\"array: %t\", arr)\nputln(\"first: %d\", arr:first())\nputln(\"final: %d\", arr:final())\nOutput:\narray: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]\nfirst: 1\nfinal: 10\nExample: Using a default value\n1local arr = Array{}\nlocal x = arr:first(9)\nputln(\"x: %d\", x)\n\n1\n\nAn empty array of options.\n\n\nOutputs x: 9 as you would expect."
  },
  {
    "objectID": "pages/Array/at.html#arrayat",
    "href": "pages/Array/at.html#arrayat",
    "title": "Lulu Arrays — Element Retrieval",
    "section": "Array:at",
    "text": "Array:at\nExample:\nlocal arr = Array:range(1,10)\nputln(\"array:      %t\", arr)\nputln(\"arr:at(2):  %d\", arr:at(2))\n1putln(\"arr:at(-2): %d\", arr:at(-2))\n\n1\n\nThis pulls the element second from the end of the array.\n\n\nOutput:\narray:      [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]\narr:at(2):  2\narr:at(-2): 9"
  },
  {
    "objectID": "pages/Array/at.html#arrayrandom",
    "href": "pages/Array/at.html#arrayrandom",
    "title": "Lulu Arrays — Element Retrieval",
    "section": "Array:random",
    "text": "Array:random\nThis method returns one sample from an array of values. All values are equally likely to occur. It will return nil if the array is empty.\nExample: Rolling a die\nlocal dice = Array:range(1,6)\nputln(\"Dice: %t\", dice)\nputln(\"Roll: %d\", dice:random())\nputln(\"Roll: %d\", dice:random())\nputln(\"Roll: %d\", dice:random())\nThe output varies from run to run but might look like:\nDice: [ 1, 2, 3, 4, 5, 6 ]\nRoll: 5\nRoll: 1\nRoll: 3\nEach value is equally likely to occur, which we can check:\nlocal dice   = Array:range(1,6)\nlocal counts = {0,0,0,0,0,0}\nlocal trials = 6*1000\n1for trial = 1, trials do\n    local roll = dice:random()\n    counts[roll] = counts[roll] + 1\nend\nputln(\"After %d trials we have counts of %t\", trials, counts)\n\n1\n\nRun lots of trials and count how many times each number arises.\n\n\nThe output varies from run to run but might look like:\n1After 6000 trials we have counts of [ 980, 1025, 1051, 1008, 935, 1001 ]\n\n1\n\nIdeally, all the counts are 1000, but these are pretty close."
  },
  {
    "objectID": "pages/Array/at.html#see-also",
    "href": "pages/Array/at.html#see-also",
    "title": "Lulu Arrays — Element Retrieval",
    "section": "See Also",
    "text": "See Also\nArray:take  Array:drop  Array:take_if  Array:drop_if"
  },
  {
    "objectID": "pages/Array/flatten.html",
    "href": "pages/Array/flatten.html",
    "title": "Lulu Arrays – Flattening",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you can use flatten an Array using the method:\nArray:flatten(depth))  Returns a new Array which is a flattened version of self.  The default value for the depth parameter is 1.\nExample:\nlocal a = Array{{1,2}, {3,4}, {5,6}}\nputln(\"a:           %t\", a)\nputln(\"a:flatten(): %t\", a:flatten())\nOutputs:\na:           [ [1, 2], [3, 4], [5, 6] ]\na:flatten(): [ 1, 2, 3, 4, 5, 6 ]\nAnother Example:\nlocal a = Array{{{1,2}}, {{{3,4}}}, {5,6}}\nputln(\"a:flatten(): %t\", a:flatten())\nOutputs [ [ 1, 2 ], [ [ 3, 4 ] ], 5, 6 ].\nFor the same array, a:flatten(2) will give [ 1, 2, [3, 4], 5, 6 ], and a:flatten(3) will give [ 1, 2, 3, 4, 5, 6 ] which is also the output from a:flatten(n) for \\(n &gt; 3\\)."
  },
  {
    "objectID": "pages/Array/flatten.html#introduction",
    "href": "pages/Array/flatten.html#introduction",
    "title": "Lulu Arrays – Flattening",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you can use flatten an Array using the method:\nArray:flatten(depth))  Returns a new Array which is a flattened version of self.  The default value for the depth parameter is 1.\nExample:\nlocal a = Array{{1,2}, {3,4}, {5,6}}\nputln(\"a:           %t\", a)\nputln(\"a:flatten(): %t\", a:flatten())\nOutputs:\na:           [ [1, 2], [3, 4], [5, 6] ]\na:flatten(): [ 1, 2, 3, 4, 5, 6 ]\nAnother Example:\nlocal a = Array{{{1,2}}, {{{3,4}}}, {5,6}}\nputln(\"a:flatten(): %t\", a:flatten())\nOutputs [ [ 1, 2 ], [ [ 3, 4 ] ], 5, 6 ].\nFor the same array, a:flatten(2) will give [ 1, 2, [3, 4], 5, 6 ], and a:flatten(3) will give [ 1, 2, 3, 4, 5, 6 ] which is also the output from a:flatten(n) for \\(n &gt; 3\\)."
  },
  {
    "objectID": "pages/Array/flatten.html#see-also",
    "href": "pages/Array/flatten.html#see-also",
    "title": "Lulu Arrays – Flattening",
    "section": "See Also",
    "text": "See Also\nArray:zip"
  },
  {
    "objectID": "pages/Array/counts.html",
    "href": "pages/Array/counts.html",
    "title": "Lulu Arrays — Values and Counts",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you have access to the following methods:\nArray:counts()  Returns a map of the values in self to the number of times they occur.\nArray:to_set()  Returns a set from self. The set is a table whose keys are the unique values in self. The associated values in that table are always true.\nArray:to_map()  Returns a table where the keys are the values in self, and the table values are the corresponding indices.  If a value occurs more than once in an array, the table value will be the index of the first occurrence.\nExample:\n1local arr = Array{'a', 'b', 'a', 'c', 'b', 'a'}\nputln(\"The array:       %t\", arr)\nputln(\"As a set:        %t\", arr:to_set())\nputln(\"As a map:        %t\", arr:to_map())\nputln(\"Value counts:    %t\", arr:counts())\n\n1\n\nWe set up an Array with some repeated values.\n\n\nOutput:\nThe array:       [ \"a\", \"b\", \"a\", \"c\", \"b\", \"a\" ]\n1As a set:        { a = true, b = true, c = true }\n2As a map:        { a = 1, b = 2, c = 4 }\n3Value counts:    { a = 3, b = 2, c = 1 }\n\n1\n\nThere are just three distinct elements in the array.\n\n2\n\n“a” occurs more than once, but the first occurrence is at index 1, and ditto for “b” at index 2\n\n3\n\nIn all, “a” occurs 3 times, “b” occurs twice, and “c” occurs just once."
  },
  {
    "objectID": "pages/Array/counts.html#introduction",
    "href": "pages/Array/counts.html#introduction",
    "title": "Lulu Arrays — Values and Counts",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you have access to the following methods:\nArray:counts()  Returns a map of the values in self to the number of times they occur.\nArray:to_set()  Returns a set from self. The set is a table whose keys are the unique values in self. The associated values in that table are always true.\nArray:to_map()  Returns a table where the keys are the values in self, and the table values are the corresponding indices.  If a value occurs more than once in an array, the table value will be the index of the first occurrence.\nExample:\n1local arr = Array{'a', 'b', 'a', 'c', 'b', 'a'}\nputln(\"The array:       %t\", arr)\nputln(\"As a set:        %t\", arr:to_set())\nputln(\"As a map:        %t\", arr:to_map())\nputln(\"Value counts:    %t\", arr:counts())\n\n1\n\nWe set up an Array with some repeated values.\n\n\nOutput:\nThe array:       [ \"a\", \"b\", \"a\", \"c\", \"b\", \"a\" ]\n1As a set:        { a = true, b = true, c = true }\n2As a map:        { a = 1, b = 2, c = 4 }\n3Value counts:    { a = 3, b = 2, c = 1 }\n\n1\n\nThere are just three distinct elements in the array.\n\n2\n\n“a” occurs more than once, but the first occurrence is at index 1, and ditto for “b” at index 2\n\n3\n\nIn all, “a” occurs 3 times, “b” occurs twice, and “c” occurs just once."
  },
  {
    "objectID": "pages/Array/counts.html#see-also",
    "href": "pages/Array/counts.html#see-also",
    "title": "Lulu Arrays — Values and Counts",
    "section": "See Also",
    "text": "See Also\nArray:drop_duplicates"
  },
  {
    "objectID": "pages/Array/meta.html",
    "href": "pages/Array/meta.html",
    "title": "Lulu Arrays — Metamethods etc.",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen you have access to the following methods & metamethods.\nArray:is_instance(obj)  Returns true if obj is an instance of the Array class or a subclass.\nArray:name()  Returns self.__name which is just Array for the base class.\nArray.__call  This make any Array(...) call a synonym for Array:new.\nArray.__eq  If a and b are Array instances this points code lke a == b and a ~= b use Array:eq under the covers.\nArray.__tostring  If a is an Array instance this points code lke print(a) or tostring(a) to {Array.tostring} under the covers.\nArray.__name  This is a piece of string data occasionally used by Lua and also returned by the Array:name() method above. It is set to “Array” for the base class.\nArray.__concat  If a and b are Array instances then we have overloaded a .. b to return a:copy():append(b).\nExample\n1local CheckedArray = Array:subclass(\"CheckedArray\")\nlocal a = Array{1,2,3}\nlocal c = CheckedArray{1,2,3}\nputln(\"a is an '%s' with values: %t\", a:name(), a)\nputln(\"c is a '%s' with values: %t\", c:name(), c)\n\n1\n\nCreate CheckedArray as a subclass of Array.\n\n\nOutput\na is an 'Array' with values: [ 1, 2, 3 ]\nc is a 'CheckedArray' with values: [ 1, 2, 3 ]\nNote that any CheckedArray is also an Array but not vice-versa:\nputln(\"a is an Array:       %s\", Array:is_instance(a))\nputln(\"c is an Array:       %s\", Array:is_instance(c))\nputln(\"a is a CheckedArray: %s\", CheckedArray:is_instance(a))\nOutput\na is an Array:       true\nc is an Array:       true\na is a CheckedArray: false\nExample: Concatenation\nlocal a = Array{1,2,3}\nlocal b = Array{3,4,5}\nlocal c = a .. b\nputln(\"a: %t\", a)\nputln(\"b: %t\", b)\nputln(\"c: %t\", c)\nOutput: Concatenation\n1a: [ 1, 2, 3 ]\n2b: [ 3, 4, 5 ]\n3c: [ 1, 2, 3, 3, 4, 5 ]\n\n1\n\na is unchanged.\n\n2\n\nb is unchanged.\n\n3\n\nc has the same elements as a:append(b) so there is duplication in this instance."
  },
  {
    "objectID": "pages/Array/meta.html#introduction",
    "href": "pages/Array/meta.html#introduction",
    "title": "Lulu Arrays — Metamethods etc.",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen you have access to the following methods & metamethods.\nArray:is_instance(obj)  Returns true if obj is an instance of the Array class or a subclass.\nArray:name()  Returns self.__name which is just Array for the base class.\nArray.__call  This make any Array(...) call a synonym for Array:new.\nArray.__eq  If a and b are Array instances this points code lke a == b and a ~= b use Array:eq under the covers.\nArray.__tostring  If a is an Array instance this points code lke print(a) or tostring(a) to {Array.tostring} under the covers.\nArray.__name  This is a piece of string data occasionally used by Lua and also returned by the Array:name() method above. It is set to “Array” for the base class.\nArray.__concat  If a and b are Array instances then we have overloaded a .. b to return a:copy():append(b).\nExample\n1local CheckedArray = Array:subclass(\"CheckedArray\")\nlocal a = Array{1,2,3}\nlocal c = CheckedArray{1,2,3}\nputln(\"a is an '%s' with values: %t\", a:name(), a)\nputln(\"c is a '%s' with values: %t\", c:name(), c)\n\n1\n\nCreate CheckedArray as a subclass of Array.\n\n\nOutput\na is an 'Array' with values: [ 1, 2, 3 ]\nc is a 'CheckedArray' with values: [ 1, 2, 3 ]\nNote that any CheckedArray is also an Array but not vice-versa:\nputln(\"a is an Array:       %s\", Array:is_instance(a))\nputln(\"c is an Array:       %s\", Array:is_instance(c))\nputln(\"a is a CheckedArray: %s\", CheckedArray:is_instance(a))\nOutput\na is an Array:       true\nc is an Array:       true\na is a CheckedArray: false\nExample: Concatenation\nlocal a = Array{1,2,3}\nlocal b = Array{3,4,5}\nlocal c = a .. b\nputln(\"a: %t\", a)\nputln(\"b: %t\", b)\nputln(\"c: %t\", c)\nOutput: Concatenation\n1a: [ 1, 2, 3 ]\n2b: [ 3, 4, 5 ]\n3c: [ 1, 2, 3, 3, 4, 5 ]\n\n1\n\na is unchanged.\n\n2\n\nb is unchanged.\n\n3\n\nc has the same elements as a:append(b) so there is duplication in this instance."
  },
  {
    "objectID": "pages/Array/meta.html#see-also",
    "href": "pages/Array/meta.html#see-also",
    "title": "Lulu Arrays — Metamethods etc.",
    "section": "See Also",
    "text": "See Also\nArray:new  Array:subclass  Array:eq  Array:append  Array:copy"
  },
  {
    "objectID": "pages/Array/to_string.html",
    "href": "pages/Array/to_string.html",
    "title": "Lulu Arrays — Stringification",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen you can convert Array instances to strings using these methods:\nArray:inline() Returns a one-line string representation of self. This is the default method used by print and friends.\nArray:pretty() Returns a “pretty” multiline string representation of self.\nArray:alt() Returns a alternate, slightly more compact, “pretty” multiline string representation of self.\nArray:classic() Returns a “classic” multiline string representation of self.\nArray:inline_json() Returns a one-line “JSON” string representation of self.\nArray:json() Returns a “JSON” multiline string representation of self.\n\n    \n     \n    \n    \nThe class also points the standard Lua tostring method at Array.inline which means that the print method and friends all automatically use self:inline() to turn an Array into a string where needed.\n\nThese methods use the facilities in the lulu.scribe module and can handle an Array instance with cycles and self references.\nExample: Simple Arrays\nlocal fruits = Array{'Apple', 'Pear', 'Banana'}\nprint(\"Inline Format:\", fruits:inline())\nprint(\"Pretty Format:\", fruits:pretty())\nprint(\"Alt Format:\")\nprint(fruits:alt())\nOutput: Simple Arrays\nInline Format:  [ \"Apple\", \"Pear\", \"Banana\" ]\nPretty Format:  [ \"Apple\", \"Pear\", \"Banana\" ]\nAlt Format:\n\"Apple\",\n\"Pear\",\n\"Banana\"\nAnother Example\nlocal a = Array{{1,2,3}, {4,5,6}}\nprint(\"Inline Format:\", a:inline())\nprint(\"Pretty Format:\")\nprint(a:pretty())\nOutput\nInline Format:  [ [ 1, 2, 3 ], [ 4, 5, 6 ] ]\nPretty Format:\n[\n    [ 1, 2, 3 ],\n    [ 4, 5, 6 ]\n]\nAn Example with a Cycle\nlocal a, b = Array{1,2,3}\n1a[4] = a\nprint(\"Inline Format:\", a:inline())\n\n1\n\nWe add a fourth elements to a that is a (spurious) self-reference.\n\n\nOutput\nInline Format:  &lt;table&gt; = [ 1, 2, 3, &lt;table&gt; ]"
  },
  {
    "objectID": "pages/Array/to_string.html#introduction",
    "href": "pages/Array/to_string.html#introduction",
    "title": "Lulu Arrays — Stringification",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen you can convert Array instances to strings using these methods:\nArray:inline() Returns a one-line string representation of self. This is the default method used by print and friends.\nArray:pretty() Returns a “pretty” multiline string representation of self.\nArray:alt() Returns a alternate, slightly more compact, “pretty” multiline string representation of self.\nArray:classic() Returns a “classic” multiline string representation of self.\nArray:inline_json() Returns a one-line “JSON” string representation of self.\nArray:json() Returns a “JSON” multiline string representation of self.\n\n    \n     \n    \n    \nThe class also points the standard Lua tostring method at Array.inline which means that the print method and friends all automatically use self:inline() to turn an Array into a string where needed.\n\nThese methods use the facilities in the lulu.scribe module and can handle an Array instance with cycles and self references.\nExample: Simple Arrays\nlocal fruits = Array{'Apple', 'Pear', 'Banana'}\nprint(\"Inline Format:\", fruits:inline())\nprint(\"Pretty Format:\", fruits:pretty())\nprint(\"Alt Format:\")\nprint(fruits:alt())\nOutput: Simple Arrays\nInline Format:  [ \"Apple\", \"Pear\", \"Banana\" ]\nPretty Format:  [ \"Apple\", \"Pear\", \"Banana\" ]\nAlt Format:\n\"Apple\",\n\"Pear\",\n\"Banana\"\nAnother Example\nlocal a = Array{{1,2,3}, {4,5,6}}\nprint(\"Inline Format:\", a:inline())\nprint(\"Pretty Format:\")\nprint(a:pretty())\nOutput\nInline Format:  [ [ 1, 2, 3 ], [ 4, 5, 6 ] ]\nPretty Format:\n[\n    [ 1, 2, 3 ],\n    [ 4, 5, 6 ]\n]\nAn Example with a Cycle\nlocal a, b = Array{1,2,3}\n1a[4] = a\nprint(\"Inline Format:\", a:inline())\n\n1\n\nWe add a fourth elements to a that is a (spurious) self-reference.\n\n\nOutput\nInline Format:  &lt;table&gt; = [ 1, 2, 3, &lt;table&gt; ]"
  },
  {
    "objectID": "pages/Array/to_string.html#see-also",
    "href": "pages/Array/to_string.html#see-also",
    "title": "Lulu Arrays — Stringification",
    "section": "See Also",
    "text": "See Also\nlulu.scribe"
  },
  {
    "objectID": "pages/Array/sub.html",
    "href": "pages/Array/sub.html",
    "title": "Lulu Arrays — Elements and Sub-Arrays",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you can use the following methods to extract sub-arrays.\nArray:most()  Returns a new array that is a copy of self with the final element removed.\nArray:rest()  Returns a new array that is a copy of self with the first element removed.\nArray:take(m,n)  Returns a new array that is a copy of the elements from index m to index n inclusive. Negative m and n count back from the end of the array. If there is no n argument, we take the first or final m elements. The no-argument call take() takes all but the final element; this is the same as most().\nArray:take_if(predicate,...)  Returns a new array that is a copy of those elements in self that pass a test.\nArray:drop(m,n)  Returns a new array that is a copy of self without the elements from index m to index n inclusive. Negative m and n count back from the end of the array. If there is no n argument, we drop the first or final m elements. The no-argument call self:drop() drops the first element; this is the same as self:rest().\nArray:drop_duplicates()  Returns a new array that is a copy of self with any duplicate elements removed.\nArray:drop_if(predicate,...)  Returns a new array that is a copy of self without any element that passes a predicate test."
  },
  {
    "objectID": "pages/Array/sub.html#introduction",
    "href": "pages/Array/sub.html#introduction",
    "title": "Lulu Arrays — Elements and Sub-Arrays",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you can use the following methods to extract sub-arrays.\nArray:most()  Returns a new array that is a copy of self with the final element removed.\nArray:rest()  Returns a new array that is a copy of self with the first element removed.\nArray:take(m,n)  Returns a new array that is a copy of the elements from index m to index n inclusive. Negative m and n count back from the end of the array. If there is no n argument, we take the first or final m elements. The no-argument call take() takes all but the final element; this is the same as most().\nArray:take_if(predicate,...)  Returns a new array that is a copy of those elements in self that pass a test.\nArray:drop(m,n)  Returns a new array that is a copy of self without the elements from index m to index n inclusive. Negative m and n count back from the end of the array. If there is no n argument, we drop the first or final m elements. The no-argument call self:drop() drops the first element; this is the same as self:rest().\nArray:drop_duplicates()  Returns a new array that is a copy of self with any duplicate elements removed.\nArray:drop_if(predicate,...)  Returns a new array that is a copy of self without any element that passes a predicate test."
  },
  {
    "objectID": "pages/Array/sub.html#arraymost-arrayrest",
    "href": "pages/Array/sub.html#arraymost-arrayrest",
    "title": "Lulu Arrays — Elements and Sub-Arrays",
    "section": "Array:most & Array:rest",
    "text": "Array:most & Array:rest\nExample\nlocal arr = Array:range(1,10)\nputln(\"array: %t\", arr)\nputln(\"first: %d\", arr:first())\nputln(\"rest:  %t\", arr:rest())\nputln(\"final: %d\", arr:final())\nputln(\"most:  %t\", arr:most())\nOutput\narray: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]\nfirst: 1\nrest:  [ 2, 3, 4, 5, 6, 7, 8, 9, 10 ]\nfinal: 10\nmost:  [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]"
  },
  {
    "objectID": "pages/Array/sub.html#arraytake",
    "href": "pages/Array/sub.html#arraytake",
    "title": "Lulu Arrays — Elements and Sub-Arrays",
    "section": "Array:take",
    "text": "Array:take\nThis returns a sub-array from self.\nReturns a new array that is a copy of the elements from index m to index n inclusive. Negative m and n count back from the end of the array. If there is no n argument, we take the first or final m elements. The no-argument call take() takes all but the final element; this is the same as most().\nExample:\nlocal arr = Array:range(1,10)\nputln(\"array:       %t\", arr)\nputln(\"take(3):     %t\", arr:take(3))\nputln(\"take(-3):    %t\", arr:take(-3))\nputln(\"take(3,5):   %t\", arr:take(3,5))\nputln(\"take(-5,-3): %t\", arr:take(-5,-3))\nputln(\"take():      %t\", arr:take())\nOutput:\narray:       [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]\n1take(3):     [ 1, 2, 3 ]\n2take(-3):    [ 8, 9, 10 ]\n3take(3,5):   [ 3, 4, 5 ]\n4take(-5,-3): [ 6, 7, 8 ]\n5take():      [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n\n1\n\nCopied the first three elements.\n\n2\n\nCopied the final three elements.\n\n3\n\nCopied elements 3,4, and 5.\n\n4\n\nCopied elements 6,7, and 8.\n\n5\n\nCopied all elements except the final one."
  },
  {
    "objectID": "pages/Array/sub.html#arraytake_if",
    "href": "pages/Array/sub.html#arraytake_if",
    "title": "Lulu Arrays — Elements and Sub-Arrays",
    "section": "Array:take_if",
    "text": "Array:take_if\nExample\nlocal arr = Array:range(1,10)\nputln(\"array: %t\", arr)\nputln(\"evens: %t\", arr:take_if(\"|x| x%2 == 0\"))\nOutput\narray: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]\nevens: [ 2, 4, 6, 8, 10 ]"
  },
  {
    "objectID": "pages/Array/sub.html#arraydrop",
    "href": "pages/Array/sub.html#arraydrop",
    "title": "Lulu Arrays — Elements and Sub-Arrays",
    "section": "Array:drop",
    "text": "Array:drop\nThis is the counterpart to Array:take.\nReturns a new array that is a copy of self without the elements from index m to index n inclusive. Negative m and n count back from the end of the array. If there is no n argument, we drop the first or final m elements. The no-argument call self:drop() drops the first element; this is the same as self:rest().\nExample:\nlocal arr = Array:range(1,10)\nputln(\"array:       %t\", arr)\nputln(\"drop(3):     %t\", arr:drop(3))\nputln(\"drop(-3):    %t\", arr:drop(-3))\nputln(\"drop(3,5):   %t\", arr:drop(3,5))\nputln(\"drop(-5,-3): %t\", arr:drop(-5,-3))\nputln(\"drop():      %t\", arr:drop())\nOutput:\narray:       [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]\n1drop(3):     [ 4, 5, 6, 7, 8, 9, 10 ]\n2drop(-3):    [ 1, 2, 3, 4, 5, 6, 7 ]\n3drop(3,5):   [ 1, 2, 6, 7, 8, 9, 10 ]\n4drop(-5,-3): [ 1, 2, 3, 4, 5, 9, 10 ]\n5drop():      [ 2, 3, 4, 5, 6, 7, 8, 9 ]\n\n1\n\nDropped the first three elements.\n\n2\n\nDropped the final three elements.\n\n3\n\nDropped elements 3,4, and 5.\n\n4\n\nDropped elements 6,7, and 8.\n\n5\n\nDropped the first element."
  },
  {
    "objectID": "pages/Array/sub.html#arraydrop_if",
    "href": "pages/Array/sub.html#arraydrop_if",
    "title": "Lulu Arrays — Elements and Sub-Arrays",
    "section": "Array:drop_if",
    "text": "Array:drop_if\nExample\nlocal arr = Array:range(1,10)\nputln(\"array: %t\", arr)\nputln(\"odds:  %t\", arr:drop_if(\"|x| x%2 == 1\"))\nOutput\narray: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]\nodds:  [ 2, 4, 6, 8, 10 ]"
  },
  {
    "objectID": "pages/Array/sub.html#arraydrop_duplicates",
    "href": "pages/Array/sub.html#arraydrop_duplicates",
    "title": "Lulu Arrays — Elements and Sub-Arrays",
    "section": "Array:drop_duplicates",
    "text": "Array:drop_duplicates\nThis returns a new array that is a copy of self with any duplicate values removed.\nExample\nlocal arr = Array{1,2,3,3,3,4,5,5,6,6}\nputln(\"array:           %t\", arr)\nputln(\"drop_duplicates: %t\", arr:drop_duplicates())\nOutput\narray:           [ 1, 2, 3, 3, 3, 4, 5, 5, 6, 6 ]\ndrop_duplicates: [ 1, 2, 3, 4, 5, 6 ]"
  },
  {
    "objectID": "pages/Array/sub.html#predicate-functions",
    "href": "pages/Array/sub.html#predicate-functions",
    "title": "Lulu Arrays — Elements and Sub-Arrays",
    "section": "Predicate Functions",
    "text": "Predicate Functions\nThe predicate function will be called as predicate(arr[i],...) for each element arr[i] in the array. It should return true if that element is considered to have passed the test.\nThe function is passed any extra ... arguments that were given to the original class method call, and of course, it may ignore those.\nThe “function” can come in several forms. For example, if you wish to extract the positive elements in an array, you could form the test as follows:\n\narr:take_where(function(v) return v &gt; 0 end)\narr:take_where(\"&gt;\", 0)\narr:take_where(\"|v| v &gt; 0\")\narr:take_where(\"_ &gt; 0\")\nYou can pass a “table” that is callable, i.e., it has a __call() metamethod that does the appropriate thing.\n\nThere is more detail in the documentation for the lulu.callable module."
  },
  {
    "objectID": "pages/Array/sub.html#see-also",
    "href": "pages/Array/sub.html#see-also",
    "title": "Lulu Arrays — Elements and Sub-Arrays",
    "section": "See Also",
    "text": "See Also\nArray:first  Array:final  Array:range  Array:delete  Array:keep  Array:keep_if  lulu.callable"
  },
  {
    "objectID": "pages/Array/eq.html",
    "href": "pages/Array/eq.html",
    "title": "Lulu Arrays — Equality Checking",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen you can check for equality between Array instances using the Array:eq method:\nArray:eq(rhs, check_mt) Returns true if self & rhs are both Arrays of the same type with identical content. This method does a deep comparison between Arrays with table elements. It can handle table elements with recursive and cyclical references.\nThe check_mt argument is optional and defaults to true.\nIf you set check_mt to false then the method will only check the content of the arrays and not the metatables.\n\n    \n     \n    \n    \nThe class also points the standard Lua comparison operators at this method so that a == b and a ~= b will call a:eq(b) under the covers.\n\nExample\n1local a, b = Array{1,2,3}, Array{1,2,3}\n2putln(\"a: %t\", a)\nputln(\"b: %t\", b)\n3putln(\"a:eq(b)       returns: %s\", a:eq(b))\n4putln(\"rawequal(a,b) returns: %s\", rawequal(a,b))\n5putln(\"a == b        returns: %s\", a == b)\n\n1\n\nSet up two simple Array instances with identical content.\n\n2\n\nWe use putln from lulu.scribe for formatted output.\n\n3\n\nThe eq method checks that a is the same type and has the same content as b.\n\n4\n\nBy default, a statement like a == b uses Lua’s rawequal call that looks the memory addresses for a and b.\n\n5\n\nHowever, we overrode a == b so that it instead uses a:eq(b) under the covers.\n\n\nOutput\na: [ 1, 2, 3 ]\nb: [ 1, 2, 3 ]\n1a:eq(b)       returns: true\n2rawequal(a,b) returns: false\n3a == b        returns: true\n\n1\n\nHere a and b have identical elements so eq returns true.\n\n2\n\nThe two arrays occupy separate memory regions so rawequal(a,b) return false.\n\n3\n\nNevertheless, a == b returns the intuitively correct true answer.\n\n\nAnother Example\n1local a, b = Array{{1,2,3}, {4,5,6}}, Array{{1,2,3}, {4,5,6}}\nputln(\"a: %t\", a)\nputln(\"b: %t\", b)\nputln(\"a:eq(b)       returns: %s\", a:eq(b))\nputln(\"rawequal(a,b) returns: %s\", rawequal(a,b))\nputln(\"a == b        returns: %s\", a == b)\n\n1\n\nOnce again, a and b have identical content. However, in this case, the array elements are themselves Lua tables.\n\n\nOutput\na: [ [ 1, 2, 3 ], [ 4, 5, 6 ] ]\nb: [ [ 1, 2, 3 ], [ 4, 5, 6 ] ]\n1a:eq(b)       returns: true\n2rawequal(a,b) returns: false\n3a == b        returns: true\n\n1\n\nThe deep check for content equality passes as we’d expect.\n\n2\n\na and b occupy separate memory regions so this check for address equality fails.\n\n3\n\nOnce again, a == b returns the intuitively correct true answer.\n\n\nAn Example with a Cycle\nlocal a, b = Array{ 1,2,3} , Array{ 1,2,3 }\n1a[4] = a\nb[4] = b\nputln(\"a: %t\", a)\nputln(\"b: %t\", b)\nputln(\"a:eq(b)       returns: %s\", a:eq(b))\nputln(\"rawequal(a,b) returns: %s\", rawequal(a,b))\nputln(\"a == b        returns: %s\", a == b)\n\n1\n\nWe add a fourth elements to the Arrays that is a (spurious) self-reference.\n\n\nOutput\na: &lt;table&gt; = [ 1, 2, 3, &lt;table&gt; ]\nb: &lt;table&gt; = [ 1, 2, 3, &lt;table&gt; ]\n1a:eq(b)       returns: true\n2rawequal(a,b) returns: false\n3a == b        returns: true\n\n1\n\nThe self-references are handled without any stack overflow and the eq method sees that the content of a and b matches.\n\n2\n\na and b occupy separate memory regions so this check for address equality fails.\n\n3\n\nOnce again, a == b returns the intuitively correct true answer as we’ve overridden the default Lua behaviour."
  },
  {
    "objectID": "pages/Array/eq.html#introduction",
    "href": "pages/Array/eq.html#introduction",
    "title": "Lulu Arrays — Equality Checking",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen you can check for equality between Array instances using the Array:eq method:\nArray:eq(rhs, check_mt) Returns true if self & rhs are both Arrays of the same type with identical content. This method does a deep comparison between Arrays with table elements. It can handle table elements with recursive and cyclical references.\nThe check_mt argument is optional and defaults to true.\nIf you set check_mt to false then the method will only check the content of the arrays and not the metatables.\n\n    \n     \n    \n    \nThe class also points the standard Lua comparison operators at this method so that a == b and a ~= b will call a:eq(b) under the covers.\n\nExample\n1local a, b = Array{1,2,3}, Array{1,2,3}\n2putln(\"a: %t\", a)\nputln(\"b: %t\", b)\n3putln(\"a:eq(b)       returns: %s\", a:eq(b))\n4putln(\"rawequal(a,b) returns: %s\", rawequal(a,b))\n5putln(\"a == b        returns: %s\", a == b)\n\n1\n\nSet up two simple Array instances with identical content.\n\n2\n\nWe use putln from lulu.scribe for formatted output.\n\n3\n\nThe eq method checks that a is the same type and has the same content as b.\n\n4\n\nBy default, a statement like a == b uses Lua’s rawequal call that looks the memory addresses for a and b.\n\n5\n\nHowever, we overrode a == b so that it instead uses a:eq(b) under the covers.\n\n\nOutput\na: [ 1, 2, 3 ]\nb: [ 1, 2, 3 ]\n1a:eq(b)       returns: true\n2rawequal(a,b) returns: false\n3a == b        returns: true\n\n1\n\nHere a and b have identical elements so eq returns true.\n\n2\n\nThe two arrays occupy separate memory regions so rawequal(a,b) return false.\n\n3\n\nNevertheless, a == b returns the intuitively correct true answer.\n\n\nAnother Example\n1local a, b = Array{{1,2,3}, {4,5,6}}, Array{{1,2,3}, {4,5,6}}\nputln(\"a: %t\", a)\nputln(\"b: %t\", b)\nputln(\"a:eq(b)       returns: %s\", a:eq(b))\nputln(\"rawequal(a,b) returns: %s\", rawequal(a,b))\nputln(\"a == b        returns: %s\", a == b)\n\n1\n\nOnce again, a and b have identical content. However, in this case, the array elements are themselves Lua tables.\n\n\nOutput\na: [ [ 1, 2, 3 ], [ 4, 5, 6 ] ]\nb: [ [ 1, 2, 3 ], [ 4, 5, 6 ] ]\n1a:eq(b)       returns: true\n2rawequal(a,b) returns: false\n3a == b        returns: true\n\n1\n\nThe deep check for content equality passes as we’d expect.\n\n2\n\na and b occupy separate memory regions so this check for address equality fails.\n\n3\n\nOnce again, a == b returns the intuitively correct true answer.\n\n\nAn Example with a Cycle\nlocal a, b = Array{ 1,2,3} , Array{ 1,2,3 }\n1a[4] = a\nb[4] = b\nputln(\"a: %t\", a)\nputln(\"b: %t\", b)\nputln(\"a:eq(b)       returns: %s\", a:eq(b))\nputln(\"rawequal(a,b) returns: %s\", rawequal(a,b))\nputln(\"a == b        returns: %s\", a == b)\n\n1\n\nWe add a fourth elements to the Arrays that is a (spurious) self-reference.\n\n\nOutput\na: &lt;table&gt; = [ 1, 2, 3, &lt;table&gt; ]\nb: &lt;table&gt; = [ 1, 2, 3, &lt;table&gt; ]\n1a:eq(b)       returns: true\n2rawequal(a,b) returns: false\n3a == b        returns: true\n\n1\n\nThe self-references are handled without any stack overflow and the eq method sees that the content of a and b matches.\n\n2\n\na and b occupy separate memory regions so this check for address equality fails.\n\n3\n\nOnce again, a == b returns the intuitively correct true answer as we’ve overridden the default Lua behaviour."
  },
  {
    "objectID": "pages/Array/eq.html#see-also",
    "href": "pages/Array/eq.html#see-also",
    "title": "Lulu Arrays — Equality Checking",
    "section": "See Also",
    "text": "See Also\nArray:copy"
  },
  {
    "objectID": "pages/paths/index.html",
    "href": "pages/paths/index.html",
    "title": "Rudimentary Path Utilities",
    "section": "",
    "text": "The lulu.paths module has a few functions for manipulating file paths.",
    "crumbs": [
      "Home",
      "Path Utilities"
    ]
  },
  {
    "objectID": "pages/paths/index.html#introduction",
    "href": "pages/paths/index.html#introduction",
    "title": "Rudimentary Path Utilities",
    "section": "",
    "text": "The lulu.paths module has a few functions for manipulating file paths.",
    "crumbs": [
      "Home",
      "Path Utilities"
    ]
  },
  {
    "objectID": "pages/paths/index.html#methods",
    "href": "pages/paths/index.html#methods",
    "title": "Rudimentary Path Utilities",
    "section": "Methods",
    "text": "Methods\nIf you have imported the module as\nlocal paths = require 'lulu.paths'\nthen you have access to the following methods:\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\npaths.components(path)\nSplits a path into a directory, basename, and extension.\n\n\npaths.basename(path)\nReturns the basename part of a path. This includes the file extension.\n\n\npaths.dirname(path)\nReturns the directory part of a path.\n\n\npaths.extension(path)\nReturns the extension part of a path.\n\n\npaths.filename(path)\nReturns the basename for the path without its extension if there is one.\n\n\npaths.script_path()\nReturns the path for the current script.\n\n\npaths.script_name()\nReturns the name for the current script w/o any .lua extension.\n\n\npaths.os_directory_separator()\nReturns the directory separator for the current platform.\n\n\npaths.is_windows()\nReturns true if the current platform is Windows, false otherwise.\n\n\npaths.is_unix()\nReturns true if the current platform is Unix, false otherwise.\n\n\npaths.is_posix()\nReturns true if the current platform is POSIX, false otherwise.\n\n\npaths.join(...)\nReturns a path from a list of path segments.\n\n\npaths.exists(path)\nReturns true if a path exists in the filesystem, false otherwise.\n\n\npaths.is_directory(path)\nReturns true if a path exists in the filesystem and is a directory, false otherwise.",
    "crumbs": [
      "Home",
      "Path Utilities"
    ]
  },
  {
    "objectID": "pages/paths/index.html#example",
    "href": "pages/paths/index.html#example",
    "title": "Rudimentary Path Utilities",
    "section": "Example",
    "text": "Example\nlocal paths = require('lulu.paths')\nlocal putln = require('lulu.scribe').putln\n\n1local path = [[/Users/Jorge/Dev/lua/test.lua]]\nlocal dir, base, ext = paths.components(path)\nlocal filename = paths.filename(path)\nlocal script_name = paths.script_name()\n\nputln(\"Script:    %s\", script_name)\nputln(\"\")\nputln(\"Path:      %s\", path)\nputln(\"Directory: %s\", dir)\nputln(\"Basename:  %s\", base)\nputln(\"Filename:  %s\", filename)\nputln(\"Extension: %s\", ext)\n\n2path = [[C:\\Users\\Jorge\\Dev\\lua\\test.lua]]\ndir, base, ext = paths.components(path)\nfilename = paths.filename(path)\nscript_name = paths.script_name()\n\nputln(\"\")\nputln(\"Path:      %s\", path)\nputln(\"Directory: %s\", dir)\nputln(\"Basename:  %s\", base)\nputln(\"Filename:  %s\", filename)\nputln(\"Extension: %s\", ext)\n\n1\n\nA Unix path.\n\n2\n\nA Windows path.\n\n\nOutput:\nScript:    paths01\n\nPath:      /Users/Jorge/Dev/lua/test.lua\nDirectory: /Users/Jorge/Dev/lua/\nBasename:  test.lua\nFilename:  test\nExtension: lua\n\nPath:      C:\\Users\\Jorge\\Dev\\lua\\test.lua\nDirectory: C:\\Users\\Jorge\\Dev\\lua\\\nBasename:  test.lua\nFilename:  test\nExtension: lua\n\n    \n     \n    \n    \nUnix paths can have \\ in their names (rarely/never seen in practice). We ignore that fact in this implementation.",
    "crumbs": [
      "Home",
      "Path Utilities"
    ]
  },
  {
    "objectID": "pages/paths/index.html#see-also",
    "href": "pages/paths/index.html#see-also",
    "title": "Rudimentary Path Utilities",
    "section": "See Also",
    "text": "See Also\nlulu.messages",
    "crumbs": [
      "Home",
      "Path Utilities"
    ]
  },
  {
    "objectID": "pages/Enum/constructors.html",
    "href": "pages/Enum/constructors.html",
    "title": "Lulu Enums — Constructors",
    "section": "",
    "text": "Enum:new(...) and Enum(...)\nThese functions create an Enum instance from various sources:\n\n    \n     \n    \n    \nThe function call Enum(...) is a synonym for Enum:new(...).\n\n\nThe arguments can be an array of strings which are the enumerator names.  The strings can optionally have ordinal values for the enumerators embedded in them.\nThe argument can be a single long string from which we parse enumerator names.  The string can optionally have ordinal values for the enumerators embedded in it.\nThe argument can be a Lua table with string keys and and number values.  The table keys are the enumerator names and the table values are the ordinal values.\nThe argument can be a Lua table with string keys and arbitrary associated data for the corresponding enumerators.  The table keys are the enumerator names and the table values are the arbitrary associated data.  The ordinals can be specified or generated as consecutive integers starting at 1.\nThe argument can be missing.  Enum()returns an empty Enum instance that you can fill using the add_enumerator method.\n\n\n    \n     \n    \n    \nIn all cases, the enumerator names must be unique.  The enumerator ordinals can have duplicates.  If the ordinals are not specified we use consecutive integers starting at 1.  If you set a custom ordinal value for an enumerator the rest of the ordinal values increment from there."
  },
  {
    "objectID": "pages/Enum/constructors.html#introduction",
    "href": "pages/Enum/constructors.html#introduction",
    "title": "Lulu Enums — Constructors",
    "section": "",
    "text": "Enum:new(...) and Enum(...)\nThese functions create an Enum instance from various sources:\n\n    \n     \n    \n    \nThe function call Enum(...) is a synonym for Enum:new(...).\n\n\nThe arguments can be an array of strings which are the enumerator names.  The strings can optionally have ordinal values for the enumerators embedded in them.\nThe argument can be a single long string from which we parse enumerator names.  The string can optionally have ordinal values for the enumerators embedded in it.\nThe argument can be a Lua table with string keys and and number values.  The table keys are the enumerator names and the table values are the ordinal values.\nThe argument can be a Lua table with string keys and arbitrary associated data for the corresponding enumerators.  The table keys are the enumerator names and the table values are the arbitrary associated data.  The ordinals can be specified or generated as consecutive integers starting at 1.\nThe argument can be missing.  Enum()returns an empty Enum instance that you can fill using the add_enumerator method.\n\n\n    \n     \n    \n    \nIn all cases, the enumerator names must be unique.  The enumerator ordinals can have duplicates.  If the ordinals are not specified we use consecutive integers starting at 1.  If you set a custom ordinal value for an enumerator the rest of the ordinal values increment from there."
  },
  {
    "objectID": "pages/Enum/constructors.html#from-strings",
    "href": "pages/Enum/constructors.html#from-strings",
    "title": "Lulu Enums — Constructors",
    "section": "From Strings",
    "text": "From Strings\n1Suit_1 = Enum{ 'Clubs', 'Diamonds', 'Hearts', 'Spades' }\n2Suit_2 = Enum{ 'Clubs', 'Diamonds = 20', 'Hearts', 'Spades = 40' }\n3Suit_3 = Enum{ 'Clubs = 1', 'Diamonds = 2', 'Hearts = 4', 'Spades = 8' }\n4Suit_4 = Enum[[Clubs, Diamonds, Hearts, Spades]]\n5Suit_5 = Enum[[Clubs = 0, Diamond, Hearts = 3, Spades = 3]]\n\n1\n\nThe default ordinal values are 1, 2, 3, 4.\n\n2\n\nThe ordinal values are 1, 20, 21, 40.\n\n3\n\nThe ordinal values are 1, 2, 4, 8.\n\n4\n\nThe ordinal values are 1, 2, 3, 4.\n\n5\n\nThe ordinal values are 0, 1, 3, 3.\n\n\n\n    \n     \n    \n    \nIn each case, the default type of the Enum instance is Enum. If you want a different type you can set it using the Enum:set_type method.\n\nSuit_1:set_type('Suit_1')\nSuit_2:set_type('Suit_2')\nSuit_3:set_type('Suit_3')\nSuit_4:set_type('Suit_4')\nSuit_5:set_type('Suit_5')\nIf we print those Enum instances we get:\n1Suit_1: [1] Clubs, [2] Diamonds, [3] Hearts, [4] Spades\nSuit_2: [1] Clubs, [20] Diamonds, [21] Hearts, [40] Spades\nSuit_3: [1] Clubs, [2] Diamonds, [4] Hearts, [8] Spades\nSuit_4: [1] Clubs, [2] Diamonds, [3] Hearts, [4] Spades\nSuit_5: [0] Clubs, [1] Diamond, [3] Hearts, [3] Spades\n\n1\n\nAs promised, the ordinal values are 1, 2, 3, 4 etc."
  },
  {
    "objectID": "pages/Enum/constructors.html#from-tables",
    "href": "pages/Enum/constructors.html#from-tables",
    "title": "Lulu Enums — Constructors",
    "section": "From Tables",
    "text": "From Tables\nYou can create an Enum instance from a table with string keys and number values:\n1Suit_6 = Enum{ Clubs = 0, Diamonds = 1, Hearts = 2, Spades = 3 }\n\n1\n\nThe ordinal values are 0, 1 2, 3.\n\n\nMore complex enums can have associated data for each enumerator:\nSuit_7 = Enum{\n    Clubs    = { abbrev = 'C', colour = 'black', icon = '♣' },\n    Diamonds = { abbrev = 'D', colour = 'red',   icon = '♦' },\n    Hearts   = { abbrev = 'H', colour = 'red',   icon = '♥' },\n    Spades   = { abbrev = 'S', colour = 'black', icon = '♠' },\n}\nSuit_7:set_type('Suit_7')\nprint(Suit_7:pretty())\nOutput:\nSuit_7:\n1    [1] Diamonds = { abbrev = \"D\", colour = \"red\", icon = \"♦\" },\n    [2] Spades = { abbrev = \"S\", colour = \"black\", icon = \"♠\" },\n    [3] Hearts = { abbrev = \"H\", colour = \"red\", icon = \"♥\" },\n    [4] Clubs = { abbrev = \"C\", colour = \"black\", icon = \"♣\" }\n\n1\n\nThe ordinal values are automatically generated as 1, 2, 3, 4.\n\n\nYou can retrieve any of the associated data for an enumerator using the abbrev, color, or icon fields respectively. For example, Suit.Diamonds.abbrev returns 'D'.\nHere’s an example of an enum with manually set ordinal values:\nSuit_8 = Enum{\n    Clubs    = { abbrev = 'C', colour = 'black', icon = '♣', ordinal = 1 },\n    Diamonds = { abbrev = 'D', colour = 'red',   icon = '♦', ordinal = 2 },\n    Hearts   = { abbrev = 'H', colour = 'red',   icon = '♥', ordinal = 4 },\n    Spades   = { abbrev = 'S', colour = 'black', icon = '♠', ordinal = 8 },\n}\nSuit_8:set_type('Suit_8')\nputln(\"%T\", Suit_8)\nOutput:\nSuit_8:\n1    [1] Clubs = { abbrev = \"C\", colour = \"black\", icon = \"♣\" },\n    [2] Diamonds = { abbrev = \"D\", colour = \"red\", icon = \"♦\" },\n    [4] Hearts = { abbrev = \"H\", colour = \"red\", icon = \"♥\" },\n    [8] Spades = { abbrev = \"S\", colour = \"black\", icon = \"♠\" }\n\n1\n\nThe ordinal values were manually set to 1, 2, 4, 8.\n\n\n\n    \n     \n    \n    \nIf you are using enums with associated data and custom ordinal values, you should set all the ordinal values when you create the Enum instance."
  },
  {
    "objectID": "pages/Enum/constructors.html#using-the-enum-function",
    "href": "pages/Enum/constructors.html#using-the-enum-function",
    "title": "Lulu Enums — Constructors",
    "section": "Using the ENUM Function",
    "text": "Using the ENUM Function\nThe lulu.Enum module exports the Enum class.\nIt also exports an ENUM function that gives you another way to create an Enum instances with preset types.\nENUM 'Suit' { 'Clubs', 'Diamonds', 'Hearts', 'Spades' }\nThis is equivalent to:\nlocal Suit = Enum:new{ 'Clubs', 'Diamonds', 'Hearts', 'Spades' }\nSuit:set_type('Suit')\nA more complex example:\nENUM 'Suit' {\n    Clubs    = { abbrev = 'C', colour = 'black', icon = '♣', ordinal = 1 },\n    Diamonds = { abbrev = 'D', colour = 'red',   icon = '♦', ordinal = 2 },\n    Hearts   = { abbrev = 'H', colour = 'red',   icon = '♥', ordinal = 4 },\n    Spades   = { abbrev = 'S', colour = 'black', icon = '♠', ordinal = 8 },\n}\nThis is equivalent to:\nlocal Suit = Enum:new{\n    Clubs    = { abbrev = 'C', colour = 'black', icon = '♣', ordinal = 1 },\n    Diamonds = { abbrev = 'D', colour = 'red',   icon = '♦', ordinal = 2 },\n    Hearts   = { abbrev = 'H', colour = 'red',   icon = '♥', ordinal = 4 },\n    Spades   = { abbrev = 'S', colour = 'black', icon = '♠', ordinal = 8 },\n}\nSuit:set_type('Suit')"
  },
  {
    "objectID": "pages/Enum/constructors.html#see-also",
    "href": "pages/Enum/constructors.html#see-also",
    "title": "Lulu Enums — Constructors",
    "section": "See Also",
    "text": "See Also\nEnum:add_enumerator  Enum:set_type  Enum:type  Enum:tostring"
  },
  {
    "objectID": "pages/Enum/add_enumerator.html",
    "href": "pages/Enum/add_enumerator.html",
    "title": "Lulu Enums — add_enumerator",
    "section": "",
    "text": "The enumerators for an Enum instance are usually specified when the Enum is created.\nHowever, you can add an enumerator to an existing Enum using the Enum:add_enumerator method. We use this feature when we are using lulu to create domain specific languages and want to add an enumerator for a new domain.\nThe add_enumerator(name, ...) method has several forms:"
  },
  {
    "objectID": "pages/Enum/add_enumerator.html#introduction",
    "href": "pages/Enum/add_enumerator.html#introduction",
    "title": "Lulu Enums — add_enumerator",
    "section": "",
    "text": "The enumerators for an Enum instance are usually specified when the Enum is created.\nHowever, you can add an enumerator to an existing Enum using the Enum:add_enumerator method. We use this feature when we are using lulu to create domain specific languages and want to add an enumerator for a new domain.\nThe add_enumerator(name, ...) method has several forms:"
  },
  {
    "objectID": "pages/Enum/add_enumerator.html#one-argument",
    "href": "pages/Enum/add_enumerator.html#one-argument",
    "title": "Lulu Enums — add_enumerator",
    "section": "One Argument",
    "text": "One Argument\nEnum:add_enumerator(name)  Adds an enumerator with the given name to the Enum instance.\nThe ordinal value for the enumerator is generated as the next consecutive integer in the existing sequence. If this is the first enumerator added to the Enum instance then the ordinal value is 1.\nExample\n1local Suit = Enum()\n2Suit:add_enumerator('Clubs')\nSuit:add_enumerator('Diamonds')\nSuit:add_enumerator('Hearts')\nSuit:add_enumerator('Spades')\nprint(Suit)\n\n1\n\nCreate an empty Enum instance.\n\n2\n\nAdd an enumerator with the name Clubs.\n\n\nThis outputs:\nEnum: [1] Clubs, [2] Diamonds, [3] Hearts, [4] Spades\nAlternatively, you can also specify the type name for the enum by using the ENUM function:\nExample\n1ENUM 'Suit' {}\n2Suit:add_enumerator('Clubs')\nSuit:add_enumerator('Diamonds')\nSuit:add_enumerator('Hearts')\nSuit:add_enumerator('Spades')\n\n1\n\nCreates an empty Enum instance with the type name Suit.\n\n2\n\nAdd an enumerator with the name Clubs.\n\n\nThis outputs:\nSuit: [1] Clubs, [2] Diamonds, [3] Hearts, [4] Spades"
  },
  {
    "objectID": "pages/Enum/add_enumerator.html#two-arguments",
    "href": "pages/Enum/add_enumerator.html#two-arguments",
    "title": "Lulu Enums — add_enumerator",
    "section": "Two Arguments",
    "text": "Two Arguments\n\n    \n     \n    \n    \nIn the two argument form, the second argument must be either a number or a table.\n\nEnum:add_enumerator(name, ordinal)  If the second argument is a number we add an enumerator to the Enum instance with the specified ordinal value.\nExample\nENUM 'Suit' {}\n1Suit:add_enumerator('Clubs',    1)\nSuit:add_enumerator('Diamonds', 2)\nSuit:add_enumerator('Hearts',   4)\nSuit:add_enumerator('Spades',   8)\nprint(Suit)\n\n1\n\nThe second argument is a number and is interpreted as the ordinal value for the enumerator.\n\n\nThis outputs:\nSuit: [1] Clubs, [2] Diamonds, [4] Hearts, [8] Spades\nEnum:add_enumerator(name, associated_data)  If the second argument is a table we add an enumerator to the Enum instance with the specified associated data. The ordinal value can be specified in the table of associated data under the ordinal field or it will be automatically generated as the next consecutive integer in the existing sequence.\nExample\nENUM 'Suit' {}\nSuit:add_enumerator('Clubs',    { color = 'black' })\nSuit:add_enumerator('Diamonds', { color = 'red'   })\nSuit:add_enumerator('Hearts',   { color = 'red'   })\nSuit:add_enumerator('Spades',   { color = 'black' })\nputln(\"%T\", Suit)\nThis outputs:\nSuit:\n1    [1] Clubs = { color = \"black\" },\n    [2] Diamonds = { color = \"red\" },\n    [3] Hearts = { color = \"red\" },\n    [4] Spades = { color = \"black\" }\n\n1\n\nThe ordinal values are automatically generated as consecutive integers starting at 1.\n\n\nYou can specify the ordinal value explicitly in the associated data by adding a numeric ordinal field to the table.\nExample\nENUM 'Suit' {}\nSuit:add_enumerator('Clubs',    { color = 'black', ordinal = 1 })\nSuit:add_enumerator('Diamonds', { color = 'red',   ordinal = 2 })\nSuit:add_enumerator('Hearts',   { color = 'red',   ordinal = 4 })\nSuit:add_enumerator('Spades',   { color = 'black', ordinal = 8 })\nputln(\"%T\", Suit)\nThis outputs:\nSuit:\n1    [1] Clubs = { color = \"black\" },\n    [2] Diamonds = { color = \"red\" },\n    [4] Hearts = { color = \"red\" },\n    [8] Spades = { color = \"black\" }\n\n1\n\nNote that the ordinal values are not cloned from the associated data but are shown in the output as [ordinal]\n\n\nYou have read access to the ordinal values using the Enumerator:tonumber() method. For example, print(Suit.Spades:tonumber()) outputs 8."
  },
  {
    "objectID": "pages/Enum/add_enumerator.html#three-arguments",
    "href": "pages/Enum/add_enumerator.html#three-arguments",
    "title": "Lulu Enums — add_enumerator",
    "section": "Three Arguments",
    "text": "Three Arguments\nEnum:add_enumerator(name, ordinal, associated_data)  In this form, the ordinal value is specified explicitly, and must be a number. The associated data must be a table. Any ordinal field in the associated data is ignored.\nExample\nENUM 'Suit' {}\nSuit:add_enumerator('Clubs',    1, { color = 'black' })\nSuit:add_enumerator('Diamonds', 2, { color = 'red'   })\nSuit:add_enumerator('Hearts',   4, { color = 'red'   })\nSuit:add_enumerator('Spades',   8, { color = 'black' })\nputln(\"%T\", Suit)\nThis outputs:\nSuit:\n    [1] Clubs = { color = \"black\" },\n    [2] Diamonds = { color = \"red\" },\n    [4] Hearts = { color = \"red\" },\n    [8] Spades = { color = \"black\" }\nWe ignore any ordinal field in the associated data if the ordinal value is specified explicitly.\nExample\nENUM 'Suit' {}\nSuit:add_enumerator('Clubs',    1, { color = 'black', ordinal = 10 })\nSuit:add_enumerator('Diamonds', 2, { color = 'red',   ordinal = 20 })\nSuit:add_enumerator('Hearts',   4, { color = 'red',   ordinal = 30 })\nSuit:add_enumerator('Spades',   8, { color = 'black', ordinal = 40 })\nputln(\"%T\", Suit)\nThis outputs:\nSuit:\n1    [1] Clubs = { color = \"black\" },\n    [2] Diamonds = { color = \"red\" },\n    [4] Hearts = { color = \"red\" },\n    [8] Spades = { color = \"black\" }\n\n1\n\nHere the ordinal values from the associated data are not used as we specified the ordinal values explicitly.\n\n\nYou are free to specify some of the the ordinal values in the associated data or have them automatically generated.\nExample\nENUM 'Suit' {}\nSuit:add_enumerator('Clubs',    1, { color = 'black', ordinal = 10 })\nSuit:add_enumerator('Diamonds', 2, { color = 'red',   ordinal = 20 })\nSuit:add_enumerator('Hearts',      { color = 'red',   ordinal = 30 })\nSuit:add_enumerator('Spades',      { color = 'black'})\nputln(\"%T\", Suit)\nThis outputs:\nSuit:\n1    [1] Clubs = { color = \"black\" },\n2    [2] Diamonds = { color = \"red\" },\n3    [30] Hearts = { color = \"red\" },\n4    [31] Spades = { color = \"black\" }\n\n1\n\nThe ordinal value in the associated data is ignored as we specified the value in the second argument.\n\n2\n\nThe ordinal value in the associated data is ignored as we specified the value in the second argument.\n\n3\n\nThe ordinal value from the associated data is used as we did not specify the ordinal value explicitly.\n\n4\n\nThis ordinal value is automatically generated as the next consecutive integer in the existing sequence."
  },
  {
    "objectID": "pages/Enum/add_enumerator.html#see-also",
    "href": "pages/Enum/add_enumerator.html#see-also",
    "title": "Lulu Enums — add_enumerator",
    "section": "See Also",
    "text": "See Also\nEnum:new  ENUM"
  },
  {
    "objectID": "pages/Enum/mt.html",
    "href": "pages/Enum/mt.html",
    "title": "Lulu Enums — Enumerator Metatables",
    "section": "",
    "text": "The enumerators within an Enum all share a common metatable.\nThat metatable inherits from a base Enumerator metatable.\nThe base metatable provides the following methods for all enumerators:\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\ntostring()\nReturns the name of the enumerator.  Enumerator names are unique within an Enum.\n\n\ntonumber()\nReturns the ordinal value of the enumerator.  By default, ordinals are consecutive integers starting at 1.  However, they can be set to other values and need not be unique.\n\n\nis_a(enum)\nReturns true if the Enumerator belongs to the argument enum.\n\n\n\n\nFor example if we have\nlocal Suit = Enum{ 'Clubs', 'Diamonds', 'Hearts', 'Spades' }\n1local s = Suit.Clubs\n\n1\n\nThe s variable is an Enumerator instance so its metatable inherits from the base Enumerator metatable.\n\n\nThen s:tostring() is “Clubs”, s:tonumber() is 1, and s:is_a(Suit) is true."
  },
  {
    "objectID": "pages/Enum/mt.html#the-base-metatable-for-enumerators",
    "href": "pages/Enum/mt.html#the-base-metatable-for-enumerators",
    "title": "Lulu Enums — Enumerator Metatables",
    "section": "",
    "text": "The enumerators within an Enum all share a common metatable.\nThat metatable inherits from a base Enumerator metatable.\nThe base metatable provides the following methods for all enumerators:\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\ntostring()\nReturns the name of the enumerator.  Enumerator names are unique within an Enum.\n\n\ntonumber()\nReturns the ordinal value of the enumerator.  By default, ordinals are consecutive integers starting at 1.  However, they can be set to other values and need not be unique.\n\n\nis_a(enum)\nReturns true if the Enumerator belongs to the argument enum.\n\n\n\n\nFor example if we have\nlocal Suit = Enum{ 'Clubs', 'Diamonds', 'Hearts', 'Spades' }\n1local s = Suit.Clubs\n\n1\n\nThe s variable is an Enumerator instance so its metatable inherits from the base Enumerator metatable.\n\n\nThen s:tostring() is “Clubs”, s:tonumber() is 1, and s:is_a(Suit) is true."
  },
  {
    "objectID": "pages/Enum/mt.html#base-metamethods",
    "href": "pages/Enum/mt.html#base-metamethods",
    "title": "Lulu Enums — Enumerator Metatables",
    "section": "Base Metamethods",
    "text": "Base Metamethods\nThe base metatable also provides the following metamethods for all enumerators:\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\n.__index(key)\nThis metamethod allows direct access to any associated data for the enumerator.\n\n\n.__newindex(key, val)\nThis metamethod prevents attempts to set values in an enumerator.\n\n\n.__tostring()\nConnects Lua’s tostring() and print methods to the Enumerator:tostring() method.\n\n\n.__eq(lhs, rhs)\nReturns true if the two arguments agree on their ordinal values.\n\n\n.__le(lhs, rhs)\nReturns true if the first argument is numerically less than or equal to the second.\n\n\n.__lt(lhs, rhs)\nReturns true if the first argument is numerically less than the second.\n\n\n\n\nFor example, if we have\nlocal Suit = Enum({\n    Clubs    = { abbrev = 'C', color = 'black', icon = '♣', ordinal = 0 },\n    Diamonds = { abbrev = 'D', color = 'red',   icon = '♦', ordinal = 1 },\n    Hearts   = { abbrev = 'H', color = 'red',   icon = '♥', ordinal = 2 },\n    Spades   = { abbrev = 'S', color = 'black', icon = '♠', ordinal = 3 }\n})\nlocal s = Suit.Hearts\nThen print(Suit.Clubs) is “Clubs”, while print(Suit.Diamonds &lt; Suit.Clubs) is false.\nYou can use the __eq metamethod to check if two enumerators are the same:\nif s == Suit.Clubs then\n    ...\nelseif s == Suit.Diamonds then\n    ...\nelseif s == Suit.Hearts then\n    ...\nelseif s == Suit.Spades then\n    ...\nend\nThis is a slightly wordy version of the C switch statement.\nThe __index metamethod allows you to directly access the associated data for an enumerator.\nFor example, if we have\nlocal s = Suit.Hearts\nThen s.abbrev is “H” and s.color is “red”.\nThe __newindex metamethod prevents you from setting values in an enumerator.\nFor example, if we have\nlocal s = Suit.Hearts\ns.abbrev = \"X\"\nWe get an error:\n[WARNING] from 'newindex' (Enum.lua:73): Enumerators are immutable -- ignoring attempt to set `Hearts.abbrev` to  \"X\"."
  },
  {
    "objectID": "pages/Enum/mt.html#custom-metatables-enummt",
    "href": "pages/Enum/mt.html#custom-metatables-enummt",
    "title": "Lulu Enums — Enumerator Metatables",
    "section": "Custom Metatables: Enum:mt",
    "text": "Custom Metatables: Enum:mt\nWhile enumerators all share a common base metatable, each Enum provides a specific metatable for its enumerators. That metatable is returned by the Enum:mt() method.\n\n    \n     \n    \n    \nAll the enumerators in an Enum share the same metatable. That metatable is a clone of the base Enumerator metatable.\n\nBy accessing the Enum:mt() metatable you can add your own methods to all the enumerators in the Enum without affecting other enums you may have created.\nFor example, if we have\nlocal Suit = Enum[[Clubs, Diamonds, Hearts, Spades]]\nWe can add a method to all the enumerators in the Suit enum:\nlocal mt = Suit:mt()\nfunction mt.is_red(self)\n    return self == Suit.Diamonds or self == Suit.Hearts\nend\nNow all the enumerators in the Suit enum have the is_red method:\nprint(Suit.Diamonds:is_red())  -- true\nprint(Suit.Hearts:is_red())    -- true\nprint(Suit.Clubs:is_red())     -- false\nprint(Suit.Spades:is_red())    -- false\nNote that only the enumerators in the Suit enum have the is_red method. The enumerators in other enums do not have it."
  },
  {
    "objectID": "pages/Enum/mt.html#see-also",
    "href": "pages/Enum/mt.html#see-also",
    "title": "Lulu Enums — Enumerator Metatables",
    "section": "See Also",
    "text": "See Also\nEnum:mt"
  },
  {
    "objectID": "pages/Enum/iter.html",
    "href": "pages/Enum/iter.html",
    "title": "Lulu Enums — Count and Iteration",
    "section": "",
    "text": "The Enum class has two methods that allow you to count and iterate over the enumerators."
  },
  {
    "objectID": "pages/Enum/iter.html#introduction",
    "href": "pages/Enum/iter.html#introduction",
    "title": "Lulu Enums — Count and Iteration",
    "section": "",
    "text": "The Enum class has two methods that allow you to count and iterate over the enumerators."
  },
  {
    "objectID": "pages/Enum/iter.html#enumcount",
    "href": "pages/Enum/iter.html#enumcount",
    "title": "Lulu Enums — Count and Iteration",
    "section": "Enum:count",
    "text": "Enum:count\nThe Enum:count() method returns the number of enumerators in the Enum.\nExample\nENUM 'Suit' { 'Clubs', 'Diamonds', 'Hearts', 'Spades' }\nputln(\"There are %d enumerators in the enum %q.\", Suit:count(), Suit:type())\nThis outputs:\nThere are 4 enumerators in the enum \"Suit\"."
  },
  {
    "objectID": "pages/Enum/iter.html#enumiter",
    "href": "pages/Enum/iter.html#enumiter",
    "title": "Lulu Enums — Count and Iteration",
    "section": "Enum:iter",
    "text": "Enum:iter\nThe Enum:iter() method returns an iterator that traverses the enumerators of the Enum in sorted order.\nExample\nENUM 'Suit' { 'Clubs', 'Diamonds', 'Hearts', 'Spades' }\nfor e in Suit:iter() do\n    putln(\"Enumerator: %s has ordinal value %d\", e, e:tonumber())\nend\nThis outputs:\nEnumerator: Clubs has ordinal value 1\nEnumerator: Diamonds has ordinal value 2\nEnumerator: Hearts has ordinal value 3\nEnumerator: Spades has ordinal value 4"
  },
  {
    "objectID": "pages/Enum/iter.html#see-also",
    "href": "pages/Enum/iter.html#see-also",
    "title": "Lulu Enums — Count and Iteration",
    "section": "See Also",
    "text": "See Also\nEnum:new  ENUM"
  },
  {
    "objectID": "pages/string/index.html",
    "href": "pages/string/index.html",
    "title": "Lua strings — Extensions",
    "section": "",
    "text": "The lulu.string module adds extra methods to the Lua string class.\nIf you have imported the module as\nrequire 'lulu.string'\nYou then have access to dozens of extra methods for any string s.\nIn practice, each method belongs to a functional group, and we first list them by those groupings. The method names within any group follow a consistent scheme.\nThe complete list of all the methods is also available in alphabetic order.",
    "crumbs": [
      "Home",
      "Extensions: string"
    ]
  },
  {
    "objectID": "pages/string/index.html#introduction",
    "href": "pages/string/index.html#introduction",
    "title": "Lua strings — Extensions",
    "section": "",
    "text": "The lulu.string module adds extra methods to the Lua string class.\nIf you have imported the module as\nrequire 'lulu.string'\nYou then have access to dozens of extra methods for any string s.\nIn practice, each method belongs to a functional group, and we first list them by those groupings. The method names within any group follow a consistent scheme.\nThe complete list of all the methods is also available in alphabetic order.",
    "crumbs": [
      "Home",
      "Extensions: string"
    ]
  },
  {
    "objectID": "pages/string/index.html#queries",
    "href": "pages/string/index.html#queries",
    "title": "Lua strings — Extensions",
    "section": "Queries",
    "text": "Queries\nQueries to check that the contents of a string s are in some particular form:\n\n\n\n\n\n\n\n\nString Method\nDescription\n\n\n\n\ns:contains_word(word)\nDoes s contain a word; a string/pattern surrounded by whitespace?\n\n\ns:contains(pattern)\nDoes s contain the string or lpeg pattern pattern?\n\n\ns:ends_with(suffix)\nReturns true if s ends with the specified suffix.\n\n\ns:is_alpha()\nReturns true if s only contains alphabetic characters.\n\n\ns:is_alphanumeric()\nReturns true if s only contains alphanumeric characters.\n\n\ns:is_bin()\nReturns true if s can be interpreted as a positive binary number.\n\n\ns:is_blank()\nReturns true if s is all white space characters.\n\n\ns:is_dec()\nReturns true if s can be interpreted as a positive integer.\n\n\ns:is_digit()\nReturns true if s only contains digit characters.\n\n\ns:is_empty()\nReturns true if s is empty (length 0).\n\n\ns:is_escaped(esc)\nReturns true if s starts with an escape character esc that defaults to the backslash character.\n\n\ns:is_float()\nReturns true if s can be interpreted as an arbitrary floating point number.\n\n\ns:is_hex()\nReturns true if s can be interpreted as a positive hexadecimal number.\n\n\ns:is_int()\nReturns true if s can be interpreted as an arbitrary integer.\n\n\ns:is_lower()\nReturns true if s only contains lowercase characters.\n\n\ns:is_non_empty()\nReturns true if s is not the empty string.\n\n\ns:is_number()\nReturns true if s can be interpreted as a number or some sort.\n\n\ns:is_oct()\nReturns true if s can be interpreted as a positive octal number.\n\n\ns:is_upper()\nReturns true if s only contains uppercase characters.\n\n\ns:starts_with(prefix)\nReturns true if s starts with the specified prefix.\n\n\n\n\nThere are a few other queries that deal with delimited text. We include them here for completeness but the details are in the later section.\n\n\n\n\n\n\n\n\nString Method\nDescription\n\n\n\n\ns:is_delimited(l, r, line)\nReturns true if s is is marked on the left by l and the right by r.\n\n\ns:contains_delimited(l,r,line)\nReturns true if s contains delimited text anywhere inside it.\n\n\ns:is_quoted()\nReturns true if s is surrounded by single or double quotes.\n\n\ns:contains_quoted()\nReturns true if s contains quoted text anywhere inside it.",
    "crumbs": [
      "Home",
      "Extensions: string"
    ]
  },
  {
    "objectID": "pages/string/index.html#end-changes",
    "href": "pages/string/index.html#end-changes",
    "title": "Lua strings — Extensions",
    "section": "End Changes",
    "text": "End Changes\nWe often need to check or perhaps change just the start or end of a string:\n\n    \n     \n    \n    \nStrings are never changed in place by these methods.  Instead a string copy with the relevant changes is returned.\n\n\n\n\n\n\n\n\n\nString Method\nDescription\n\n\n\n\ns:append(suffix)\nReturns a new string that is s with the suffix string appended to it.\n\n\ns:ellipsis(n)\nReturns a copy of s truncated after n characters with a following ” …”\n\n\ns:ensure_end(suffix)\nReturn s if it already ends with a specified suffix. Otherwise returns a new padded version that does indeed end with the required prefix.\n\n\ns:ensure_start(prefix)\nReturn s if it already starts with a specified prefix. Otherwise returns a new padded version that does indeed start with the required prefix.\n\n\ns:kill_from(p)\nReturns a copy of s where each line has from p to the end of that line removed. The p argument can be a number, a string, or an lpeg pattern.\n\n\ns:kill_to(p)\nReturns a copy of s where each line is killed from its start up to and including p. The p argument can be a number, a string, or an lpeg pattern.\n\n\ns:pad_end(len,fill)\nReturns a copy of s that has a specified minimum length by padding s on the right. The default fill is a space.\n\n\ns:pad_start(len,fill)\nReturns a copy of s that has a specified minimum length by padding s on the left. The default fill is a space.\n\n\ns:prepend(prefix)\nReturns a new string that is s with the prefix string prepended to it.\n\n\ns:strip_comments(char)\nReturns a copy of s with any end-of-line comments erased from each line.  The default comment start char is the hash symbol #.\n\n\ns:trim_end(chars)\nReturns a copy of s that has chars trimmed from the right side.  The default chars is the Lua pattern for whitespace.\n\n\ns:trim_start(chars)\nReturns a copy of s that has chars trimmed from the left side.  The default chars is the Lua pattern for whitespace.\n\n\ns:trim_ws()\nReturns a copy of s without any leading or trailing whitespace.\n\n\ns:trim(chars)\nReturns a copy of s that has chars trimmed from both the left & right sides.  The default chars is the Lua pattern for whitespace.\n\n\ns:truncate(n)\nReturns a copy of a string where each line is truncated at n characters.",
    "crumbs": [
      "Home",
      "Extensions: string"
    ]
  },
  {
    "objectID": "pages/string/index.html#general-changes",
    "href": "pages/string/index.html#general-changes",
    "title": "Lua strings — Extensions",
    "section": "General Changes",
    "text": "General Changes\nOther methods change strings anywhere as opposed to those above that only effect the start or end.\n\n    \n     \n    \n    \nStrings are never changed in place by these methods.  Instead a copy with the relevant changes is returned.\n\n\n\n\n\n\n\n\n\nString Method\nDescription\n\n\n\n\ns:add_escapes(esc,specials)\nReturns a copy of s that has an escape character added before characters in the string that need “escaping”. The default esc character is a backslash.  By default, we add the esc character before all quotation marks and the backslash.\n\n\ns:change(from, to)\nReturns a new string that is a copy of s with all occurrences of from replaced with to. The from argument can be a string or an lpeg pattern.\n\n\ns:collapse_ws(careful)\nReturns a copy of s with contiguous whitespaces converted to a single space. By default, quoted substrings in s are unaltered (careful = true).\n\n\ns:dedent_lines(indent)\nReturns a copy of s with each line’s indentation removed.  The indent argument is the string to remove from the start of each line.\n\n\ns:delete_ws()\nReturns a copy of s with all spaces removed.\n\n\ns:delete(p)\nReturns a copy of s where all matches to a string or pattern p are deleted.\n\n\ns:from_hex()\nReturns a decoded version of a hex-encoded s so e.g., “68656c6c6f” -&gt; “hello”\n\n\ns:from_lua_pattern()\nReturns a copy of s with all the ‘%’ characters from a Lua pattern removed.\n\n\ns:indent_lines(indent, ignore_first)\nReturns a copy of s with each line’s indentation removed.  The indent argument is the string to add to the start of each line.  The ignore_first argument is a boolean that defaults to false.  If true, the first line is not indented.\n\n\ns:remove_escapes(esc)\nReturns a copy of s with any esc characters removed (default is a backslash).\n\n\ns:to_bool()\nTries to interpret s as a boolean value where we recognize yes/no, on/off etc.  The case of s does not matter.\n\n\ns:to_hex()\nReturns a hex-encoded version of s so e.g., “hello” -&gt; “68656c6c6f”\n\n\ns:to_lua_pattern()\nReturns a new version s string that can be safely used in Lua’s pattern matching functions.\n\n\ns:unescape(chars,esc)\nReturns a copy of s with specific add_escapes characters turned into remove_escapes ones. The default character to unescape is the double quotation mark and the default escape character is the backslash.\n\n\n\n\nExample:\nlocal str = [[joe \\{said\\} \\\"no way\\\".]]\nprint(\"str:                      \",  str)\nprint(\"str:remove_escapes():     \",  str:remove_escapes())\nprint(\"str:unescape_chars('{}'): \",  str:unescape_chars('{}'))\nOutput\nstr:                        joe \\{said\\} \\\"no way\\\".\n1str:remove_escapes():       joe {said} \"no way\".\n2str:unescape_chars('{}'):   joe {said} \\\"no way\\\".\n\n1\n\nAll backslashes are removed from str.\n\n2\n\nOnly the backslashed braces \\{ and \\} are altered.",
    "crumbs": [
      "Home",
      "Extensions: string"
    ]
  },
  {
    "objectID": "pages/string/index.html#tokenising",
    "href": "pages/string/index.html#tokenising",
    "title": "Lua strings — Extensions",
    "section": "Tokenising",
    "text": "Tokenising\nString parsing generally involves splitting text into tokens/words that are delimited by separators such as whitespace. We have several methods to help with that task:\n\n\n\n\n\n\n\n\nString Method\nDescription\n\n\n\n\ns:after(sep)\nReturns the text after the separator sep.  The separator can be a string or an lpeg pattern.\n\n\ns:before(sep)\nReturns the text after the separator sep.  The separator can be a string or an lpeg pattern.\n\n\ns:split(sep)\nReturns an array of “tokens” in s split by a separator sep.  The default separator is the whitespace pattern.\n\n\ns:to_blocks()\nReturns a table of all the text blocks/paragraphs in s.  Blocks/paragraphs are pieces of text delimited by one or more blank lines.\n\n\ns:to_lines()\nReturns an array of all the “lines” in s by splitting on a newline character.\n\n\ns:to_tokens(sep)\nReturns an array of all the “tokens” in s by splitting it on a separator/pattern sep.  The default separator is the whitespace pattern.\n\n\n\n\nWe also have a couple of methods to access the individual characters in a string:\n\n\n\n\n\n\n\n\nString Method\nDescription\n\n\n\n\ns:iter()\nReturns an iterator for the characters in s  This can be used as for c in s:iter() do ... end  This iterator is Unicode-aware.\n\n\ns:to_array()\nReturns an array that contains the individual characters in s.  This is Unicode-aware.",
    "crumbs": [
      "Home",
      "Extensions: string"
    ]
  },
  {
    "objectID": "pages/string/index.html#delimited-text",
    "href": "pages/string/index.html#delimited-text",
    "title": "Lua strings — Extensions",
    "section": "Delimited Text",
    "text": "Delimited Text\nGiven a block of text, you often need to extract substrings surrounded by markers of some sort. For example, given a block of C/C++ code, you might want to delete any multiline comment. In C/C++ multiline comments begin with the left delimiter /* and end with the right delimiter */.\nWe have methods that work on text containing delimited strings. Some specialisations work on strings delimited by quotation marks, a typical case of interest.\n\n\n\n\n\n\n\n\nString Method\nDescription\n\n\n\n\ns:all_delimited(l,r,line)\nReturns an array of all delimited substrings in s.\n\n\ns:all_quoted()\nReturns an array of all quoted substrings in s\n\n\ns:contains_delimited(l,r,line)\nReturns true if s contains delimited text anywhere inside it.\n\n\ns:contains_quoted()\nReturns true if s contains quoted text anywhere inside it.\n\n\ns:contains_word(word)\nDoes s contain a particular word which a string or any lpeg pattern surrounded by whitespace? This is the simplest form of delimited text.\n\n\ns:first_delimited(l,r,line)\nReturns the first delimited substring found in s.\n\n\ns:first_quoted()\nReturns the first quoted substring found in s.\n\n\ns:is_delimited(l,r,line)\nReturns true if s is is marked on the left by l and the right by r.\n\n\ns:is_quoted()\nReturns true if s is surrounded by single or double quotes.\n\n\n\n\nThe various *_delimited(l, r, line) methods take three optional arguments: l and r are the left and right delimiters to look for, and both default to the double quotation mark. The line argument is a boolean that defaults to false. If set to true, matches stop at the first newline character in the string.\nThe full rules for delimiters are:\n\nIf neither is given, we set them to the default double quote character \".\nIf only one is given and it’s a single character (e.g. ') then we use that for both delimiters.\nIf only one is given and it has an even number of characters, then we split that into half. For example, if we are passed the single delimiter “{}”, then we split it in half, so in effect l = '{' and r = '}'.\nFinally, of course, you can specify l and r separately.\n\nExample\nlocal s = \"Here is a string with {text in braces}\"\nprint(\"is_delimited:       \", s:is_delimited(\"{}\"))\nprint(\"contains_delimited: \", s:contains_delimited(\"{}\"))\nprint(\"first_delimited:    \", s:first_delimited(\"{}\"))\nprint(\"all_delimited:      \", table.concat(s:all_delimited(\"{}\"), \", \"))\nOutput\nis_delimited:           false\ncontains_delimited:     true\nfirst_delimited:        text in braces\nall_delimited:          text in braces\nAnother Example\nlocal s = \"{Here} {is a string} {with} {text in braces}\"\nprint(\"is_delimited:       \", s:is_delimited(\"{}\"))\nprint(\"contains_delimited: \", s:contains_delimited(\"{}\"))\nprint(\"first_delimited:    \", s:first_delimited(\"{}\"))\nprint(\"all_delimited:      \", table.concat(s:all_delimited(\"{}\"), \", \"))\nOutput\nis_delimited:           true\ncontains_delimited:     true\nfirst_delimited:        Here\nall_delimited:          Here, is a string, with, text in braces\nNote that in this case, s starts with a \"{\" and ends with a \"}\" so the entire string is indeed delimited. However, the first_delimited and all_delimited methods work in a non-greedy manner, which is almost certainly what you would want.",
    "crumbs": [
      "Home",
      "Extensions: string"
    ]
  },
  {
    "objectID": "pages/string/index.html#all-methods",
    "href": "pages/string/index.html#all-methods",
    "title": "Lua strings — Extensions",
    "section": "All Methods",
    "text": "All Methods\nHere is an alphabetic list of all the methods added by the string module to the Lua string class for any string s.\nClick on a method to jump to the documentation section for the corresponding functional group.\n\ns:add_escapes(esc, specials)\ns:after(sep)\ns:all_delimited(l,r,line)\ns:all_quoted()\ns:append(suffix)\ns:before(sep)\ns:change(from, to)\ns:collapse_ws(careful)\ns:contains_delimited(l, r, line)\ns:contains_quoted()\ns:contains_word(word)\ns:contains(pattern)\ns:dedent_lines(indent)\ns:delete_ws()\ns:delete(p)\ns:ellipsis(n)\ns:ends_with(prefix)\ns:ensure_end(suffix)\ns:ensure_start(prefix)\ns:first_delimited(l, r, line)\ns:first_quoted()\ns:from_hex()\ns:from_lua_pattern()\ns:indent_lines(indent, ignore_first_line)\ns:is_alpha()\ns:is_alphanumeric()\ns:is_bin()\ns:is_blank()\ns:is_dec()\ns:is_delimited(l, r, line)\ns:is_digit()\ns:is_empty()\ns:is_escaped(esc)\ns:is_float()\ns:is_hex()\ns:is_int()\ns:is_lower()\ns:is_non_empty()\ns:is_number()\ns:is_oct()\ns:is_quoted()\ns:is_upper()\ns:iter()\ns:kill_from(p)\ns:kill_to(p)\ns:pad_end(len, fill)\ns:pad_start(len, fill)\ns:prepend(prefix)\ns:remove_escapes(esc)\ns:split(sep)\ns:starts_with(suffix)\ns:strip_comments(char)\ns:to_array()\ns:to_blocks()\ns:to_bool()\ns:to_hex()\ns:to_lines()\ns:to_lua_pattern()\ns:to_tokens(sep)\ns:trim(chars)\ns:trim_end(chars)\ns:trim_start(chars)\ns:trim_ws()\ns:truncate(n)\ns:unescape_chars(chars, esc)",
    "crumbs": [
      "Home",
      "Extensions: string"
    ]
  },
  {
    "objectID": "pages/string/index.html#see-also",
    "href": "pages/string/index.html#see-also",
    "title": "Lua strings — Extensions",
    "section": "See Also",
    "text": "See Also\nlulu.table  lulu.xpeg",
    "crumbs": [
      "Home",
      "Extensions: string"
    ]
  },
  {
    "objectID": "pages/table/union.html",
    "href": "pages/table/union.html",
    "title": "Lua Tables — Unions, Intersections, Differences",
    "section": "",
    "text": "If you have imported the module as\nrequire 'lulu.table'\nthen you have access to the following methods to combine general tables:\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\ntable.union(...)\nReturns a new table that is the union of the arguments.\n\n\ntable.intersection(...)\nReturns a new table that is the intersection of the arguments.\n\n\ntable.difference(t1,t2,symmetric)\nReturns a new table that is the difference between t1 and t2.\n\n\n\n\n\n    \n     \n    \n    \nThese table methods take into account a table’s keys and values when looking for commonalities and differences! Both must match (or differ as the case may be).\n\nThere are also methods to look at the keys and values separately:\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\ntable.merged_values(...)\nReturns an array of all the values from the table arguments.\n\n\ntable.merged_keys(...)\nReturns an array of all the keys from the table arguments.\n\n\ntable.common_values(...)\nReturns an array of the values that are in common between the table arguments.\n\n\ntable.common_keys(...)\nReturns an array of the keys that are in common between the table arguments.\n\n\ntable.unique_values(...)\nReturns an array of the values that are unique to each table argument.\n\n\ntable.unique_keys(...)\nReturns an array of the keys that are unique to each table argument."
  },
  {
    "objectID": "pages/table/union.html#introduction",
    "href": "pages/table/union.html#introduction",
    "title": "Lua Tables — Unions, Intersections, Differences",
    "section": "",
    "text": "If you have imported the module as\nrequire 'lulu.table'\nthen you have access to the following methods to combine general tables:\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\ntable.union(...)\nReturns a new table that is the union of the arguments.\n\n\ntable.intersection(...)\nReturns a new table that is the intersection of the arguments.\n\n\ntable.difference(t1,t2,symmetric)\nReturns a new table that is the difference between t1 and t2.\n\n\n\n\n\n    \n     \n    \n    \nThese table methods take into account a table’s keys and values when looking for commonalities and differences! Both must match (or differ as the case may be).\n\nThere are also methods to look at the keys and values separately:\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\ntable.merged_values(...)\nReturns an array of all the values from the table arguments.\n\n\ntable.merged_keys(...)\nReturns an array of all the keys from the table arguments.\n\n\ntable.common_values(...)\nReturns an array of the values that are in common between the table arguments.\n\n\ntable.common_keys(...)\nReturns an array of the keys that are in common between the table arguments.\n\n\ntable.unique_values(...)\nReturns an array of the values that are unique to each table argument.\n\n\ntable.unique_keys(...)\nReturns an array of the keys that are unique to each table argument."
  },
  {
    "objectID": "pages/table/union.html#table.union",
    "href": "pages/table/union.html#table.union",
    "title": "Lua Tables — Unions, Intersections, Differences",
    "section": "table.union",
    "text": "table.union\nThis returns a new table, the union of the passed table arguments. If a key is in more than one of the table arguments, the returned union will have an array of values for that key.\nHere is an example: We create three trivial “person” records and examine the union of those records.\nExample: Unions of general tables\nlocal p1 = {first = 'Joan', second = 'Doe'}\nlocal p2 = {first = 'John', second = 'Doe'}\nlocal p3 = {first = 'John', second = 'Smith'}\n1putln(\"p1:    %t\", p1)\nputln(\"p2:    %t\", p2)\nputln(\"p3:    %t\", p3)\nputln(\"Union: %t\", table.union(p1,p2,p3))\n\n1\n\nThe examples on this page use scribe.putln for formatted printing.\n\n\nOutput:\np1:    { first = \"Joan\", second = \"Doe\" }\np2:    { first = \"John\", second = \"Doe\" }\np3:    { first = \"John\", second = \"Smith\" }\n1Union: { first = [ \"Joan\", \"John\" ], second = [ \"Doe\", \"Smith\" ] }\n\n1\n\nThe union method returns arrays of values for the first and last keys.\n\n\n\n    \n     \n    \n    \nThe values in the union arrays are unique, so in the example, there is just one reference to “Doe”, not two.\n\nExample: Unions of arrays Remember that Lua treats arrays as tables where the keys are consecutive integers starting at 1. Often, the keys are not seen explicitly, but they are always there. Here is what the union of some simple arrays looks like:\nlocal a1 = {1,2,3,4}\nlocal a2 = {4,5,6,7}\nlocal a3 = {7,8,9,0}\nputln(\"a1:    %t\", a1)\nputln(\"a2:    %t\", a2)\nputln(\"a3:    %t\", a3)\nputln(\"Union: %t\", table.union(a1,a2,a3))\nThis yields the output:\na1:    [ 1, 2, 3, 4 ]\na2:    [ 4, 5, 6, 7 ]\na3:    [ 7, 8, 9, 0 ]\n1Union: [ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ], [ 4, 7, 0 ] ]\n\n1\n\nThe union method collected all the unique values it found under the key 1, which are {1,4,7} and then did the same for the key 2 and so on."
  },
  {
    "objectID": "pages/table/union.html#table.intersection",
    "href": "pages/table/union.html#table.intersection",
    "title": "Lua Tables — Unions, Intersections, Differences",
    "section": "table.intersection",
    "text": "table.intersection\nGiven a collection of general tables, we can look for the key-value pairs they have in common. The critical thing to remember is that an element only makes it into the intersection if both the key and the value match in all the tables.\nExample: Intersections of general tables If we take our earlier “person” record example:\nlocal p1 = {first = 'Joan', second = 'Doe'}\nlocal p2 = {first = 'John', second = 'Doe'}\nlocal p3 = {first = 'John', second = 'Smith'}\nputln(\"Intersection p1, p2:     %t\", table.intersection(p1, p2))\nputln(\"Intersection p2, p3:     %t\", table.intersection(p2, p3))\nputln(\"Intersection p3, p1:     %t\", table.intersection(p3, p1))\nputln(\"Intersection p1, p2, p3: %t\", table.intersection(p1, p2, p3))\nOutput: Intersections of general tables\n1Intersection p1, p2:     { second = \"Doe\"}\n2Intersection p2, p3:     { first = \"John\"}\n3Intersection p3, p1:     {}\n4Intersection p1, p2, p3: {}\n\n1\n\nThe first and second person share a surname.\n\n2\n\nThe second and third person share a first name.\n\n3\n\nThe third and first-person have no names in common.\n\n4\n\nSimilarly, the intersection of all the three persons is empty.\n\n\nExample: Intersections of arrays The results from taking this type of intersection of Lua arrays can, at first, seem unexpected:\nlocal a1 = {1,2,3,4}\nlocal a2 = {4,5,6,7}\nputln(\"Intersection a1, a2: %t\", table.intersection(a1, a2))\nThis yields Intersection a1, a2: {} even though the arrays have the value 4 in common.\nHowever, for a key-value pair to be part of the intersection, both the key (the array index in this case) and the value must match.\nIf we change the example, so the common value has the same index:\nlocal a1 = {1,2,3,4}\nlocal a2 = {5,6,7,4}\nputln(\"Intersection a1, a2: %t\", table.intersection(a1, a2))\nThen we get Intersection a1, a2: { 4 = 4 }."
  },
  {
    "objectID": "pages/table/union.html#table.difference",
    "href": "pages/table/union.html#table.difference",
    "title": "Lua Tables — Unions, Intersections, Differences",
    "section": "table.difference",
    "text": "table.difference\nThe difference between two tables captures the elements in one but not the other. Like the other methods on this page this function takes into account both the key and the value of an element when looking for equality.\nGenerally table.difference(t1, t2) ~= table.difference(t2, t1).\nWe sometimes refer to table.difference(t1, t2) as \\(t_1 - t_2\\).\nBy default, the boolean symmetric argument is false. You can set it to true to get the symmetric difference between \\(t_1\\) and \\(t_2\\): \\[\nt_1 - t_2 \\cup t_2 - t_1.\n\\] That is the table of top-level elements that occurs only in one of t1 or t2.\nExample:\nlocal p1 = {a = 'alpha', b = 'beta'}\n1local p2 = {a = 'gamma', b = 'beta'}\nputln(\"p1:      %t\", p1)\nputln(\"p2:      %t\", p2)\nputln(\"p1 - p2: %t\", table.difference(p1, p2))\nputln(\"p2 - p1: %t\", table.difference(p2, p1))\n\n1\n\nNote that p1 and p2 share the common key a but that the corresponding values do not match.\n\n\nOutput:\np1:      { a = \"alpha\", b = \"beta\"}\np2:      { a = \"gamma\", b = \"beta\"}\n1p1 - p2: { a = \"alpha\"}\n2p2 - p1: { a = \"gamma\"}\n\n1\n\nThe elements in p1 that are not in p2.\n\n2\n\nThe elements in p2 that are not in p1.\n\n\nIf we repeat the exercise using symmetric differencing:\nlocal p1 = {a = 'alpha', b = 'beta'}\nlocal p2 = {a = 'gamma', b = 'beta'}\nputln(\"p1 - p2: %t\", table.difference(p1, p2, true))\nputln(\"p2 - p1: %t\", table.difference(p2, p1, true))\nwe get:\n1p1 - p2: { a = [ \"alpha\", \"gamma\" ] }\np2 - p1: { a = [ \"gamma\", \"alpha\" ] }\n\n1\n\nThis shows the union \\(p_1 - p_2 \\cup p_2 - p_1\\) where they have the common key a but with two different values.\n\n\nIn both cases, we get the table of key-value pairs that only occur in one of the two tables."
  },
  {
    "objectID": "pages/table/union.html#table.merged_values-table.merged_keys",
    "href": "pages/table/union.html#table.merged_values-table.merged_keys",
    "title": "Lua Tables — Unions, Intersections, Differences",
    "section": "table.merged_values, table.merged_keys",
    "text": "table.merged_values, table.merged_keys\nThese methods return an array of all the values and keys from the table arguments.\nExample:\nlocal p1 = {first = 'Joan', second = 'Doe'}\nlocal p2 = {first = 'John', second = 'Doe'}\nlocal p3 = {first = 'John', second = 'Smith'}\nputln(\"Merged Values: %t\", table.merged_values(p1,p2,p3))\nputln(\"Merged Keys:   %t\", table.merged_keys(p1,p2,p3))\nOutput:\n1Merged Values: [ \"Joan\", \"Doe\", \"John\", \"Smith\" ]\n2Merged Keys:   [ \"first\", \"second\" ]\n\n1\n\nThe values are merged into a single array with no duplicates.\n\n2\n\nThe keys are merged into a single array with no duplicates."
  },
  {
    "objectID": "pages/table/union.html#table.common_values-table.common_keys",
    "href": "pages/table/union.html#table.common_values-table.common_keys",
    "title": "Lua Tables — Unions, Intersections, Differences",
    "section": "table.common_values, table.common_keys",
    "text": "table.common_values, table.common_keys\nThese methods return an array of the values and keys that are in common between the table arguments.\nExample:\nlocal p1 = {first = 'Joan', second = 'Doe'}\nlocal p2 = {first = 'John', second = 'Doe'}\nlocal p3 = {first = 'John', second = 'Smith'}\nputln(\"Common Values: p1, p2:     %t\", table.common_values(p1, p2))\nputln(\"Common Values: p2, p3:     %t\", table.common_values(p2, p3))\nputln(\"Common Values: p3, p1:     %t\", table.common_values(p3, p1))\nputln(\"Common Values: p1, p2, p3: %t\", table.common_values(p1, p2, p3))\nOutput:\n1Common Values: p1, p2:     [ \"Doe\" ]\n2Common Values: p2, p3:     [ \"John\" ]\n3Common Values: p3, p1:     {}\n4Common Values: p1, p2, p3: {}\n\n1\n\nThe only value that is in common between p1 and p2 is \"Doe\".\n\n2\n\nThe only value that is in common between p2 and p3 is \"John\".\n\n3\n\nThe are no common values between p3 and p1.\n\n4\n\nThe are no common values between all three tables.\n\n\nExample:\nlocal a1 = {1,2,3,4}\nlocal a2 = {4,5,6,7}\nputln(\"Common Values: a1, a2: %t\", table.common_values(a1, a2))\nOutput:\n1Common Values: a1, a2: [ 4 ]\n\n1\n\nThe only value that is in common between a1 and a2 is 4. The location of the value is not important."
  },
  {
    "objectID": "pages/table/union.html#table.unique_values-table.unique_keys",
    "href": "pages/table/union.html#table.unique_values-table.unique_keys",
    "title": "Lua Tables — Unions, Intersections, Differences",
    "section": "table.unique_values, table.unique_keys",
    "text": "table.unique_values, table.unique_keys\nThese methods return an array of the values and keys that are unique to each table argument.\nExample:\nlocal p1 = {first = 'Joan', second = 'Doe'}\nlocal p2 = {first = 'John', second = 'Doe'}\nlocal p3 = {first = 'John', second = 'Smith'}\nputln(\"Unique Values: p1 - p2: %t\", table.unique_values(p1, p2))\nputln(\"Unique Values: p2 - p1: %t\", table.unique_values(p2, p1))\nputln(\"Unique Keys:   p1 - p2: %t\", table.unique_keys(p1, p2))\nputln(\"Unique Keys:   p2 - p1: %t\", table.unique_keys(p2, p1))\nOutput:\n1Unique Values: p1 - p2: [ \"Joan\" ]\n2Unique Values: p2 - p1: [ \"John\" ]\n3Unique Keys:   p1 - p2: {}\n4Unique Keys:   p2 - p1: {}\n\n1\n\nThe only value that is unique to p1 is \"Joan\".\n\n2\n\nThe only value that is unique to p2 is \"John\".\n\n3\n\nThere are no keys that are unique to p1 versus p2.\n\n4\n\nThere are no keys that are unique to p2 versus p1.\n\n\nExample:\nlocal p1 = {a = 'alpha', b = 'beta'}\nlocal p2 = {a = 'gamma', b = 'beta'}\nputln(\"p1: %t\", p1)\nputln(\"p2: %t\", p2)\nputln(\"Values only in one of p1 or p2: %t\", table.unique_values(p1, p2, true))\nputln(\"Values only in one of p2 or p1: %t\", table.unique_values(p2, p1, true))\nputln(\"Keys only in one of p1 or p2:   %t\", table.unique_keys(p1, p2, true))\nputln(\"Keys only in one of p2 or p1:   %t\", table.unique_keys(p2, p1, true))\nOutput:\np1: { a = \"alpha\", b = \"beta\" }\np2: { a = \"gamma\", b = \"beta\" }\nValues only in one of p1 or p2: [ \"alpha\", \"gamma\" ]\nValues only in one of p2 or p1: [ \"gamma\", \"alpha\" ]\nKeys only in one of p1 or p2:   {}\nKeys only in one of p2 or p1:   {}"
  },
  {
    "objectID": "pages/table/union.html#see-also",
    "href": "pages/table/union.html#see-also",
    "title": "Lua Tables — Unions, Intersections, Differences",
    "section": "See Also",
    "text": "See Also\nlulu.Array  Scribe"
  },
  {
    "objectID": "pages/table/ordered_pairs.html",
    "href": "pages/table/ordered_pairs.html",
    "title": "Lua Tables — Ordered Iteration",
    "section": "",
    "text": "If you have imported the lulu.table module as\nrequire 'lulu.table'\nthen, you have access to a new iterator maker:\ntable.ordered_pairs(comparator)  Returns an iterator maker — a function that takes a table and returns an iterator. The iterator returns key-value pairs in a fixed order determined by the comparator argument.\nLau supplies a standard pairs method that iterates through all the key-value pairs in any table. However, that traversal is done in an undefined order and can vary from run to run.\n\n    \n     \n    \n    \nLua has no defined order for the keys in a general table. This contrasts with the keys in a pure Lua array where the indices are always stored in their natural order from 1 on.\n\nWe supply a counterpart iterator table.ordered_pairs(comparator) that returns an iterator that traverses the keys in the table in a fixed order. By default, keys are sorted by type and then by value, so numeric keys come first in their natural order, and those are followed by the others where strings are sorted alphabetically.\nIf you supply a comparator argument it should take two key arguments k1, k2 and return true if you want k1 to appear before k2.\nExample\nlocal tbl = { frog = 1, badger = 2, eagle = 3 }\n1for k, v in pairs(tbl) do print(k, v) end\nprint(\"--------\")\n\n2local iter = table.ordered_pairs()\nfor k, v in iter(tbl) do print(k, v) end\nprint(\"--------\")\n\n3iter = table.ordered_pairs(\"&gt;\")\nfor k, v in iter(tbl) do print(k, v) end\n\n1\n\nLua’s standard pair method.\n\n2\n\nHere, the ordered_pairs method uses the default key comparator function.\n\n3\n\nHere, the ordered_pairs method uses a custom key comparator “function”.\n\n\noutputs\n1eagle   3\nfrog    1\nbadger  2\n--------\n2badger  2\neagle   3\nfrog    1\n--------\n3frog    1\neagle   3\nbadger  2\n\n1\n\nThe key-value pairs are output in whatever undefined order Lua stores them.\n\n2\n\nThe key-value pairs are output in our default increasing alphabetic order for the keys.\n\n3\n\nThe key-value pairs are output in a custom-decreasing alphabetic order for the keys.\n\n\n\n\nA custom comparator function can come in one of several forms:\n\nYou can use Lua functions like table.ordered_pairs(function(a,b) return a &gt; b end).\nYou can use a string operator like table.ordered_pairs(\"&gt;\").\nYou can use a string {lulu.anon} like table.ordered_pairs(\"|a,b| a &gt; b\").\nYou can pass a “table” that happens to be *callable, i.e., it has a __call() metamethod that takes two items and compares them.\n\nThere is more detail on the second and third options in the documentation for the lulu.callable module."
  },
  {
    "objectID": "pages/table/ordered_pairs.html#introduction",
    "href": "pages/table/ordered_pairs.html#introduction",
    "title": "Lua Tables — Ordered Iteration",
    "section": "",
    "text": "If you have imported the lulu.table module as\nrequire 'lulu.table'\nthen, you have access to a new iterator maker:\ntable.ordered_pairs(comparator)  Returns an iterator maker — a function that takes a table and returns an iterator. The iterator returns key-value pairs in a fixed order determined by the comparator argument.\nLau supplies a standard pairs method that iterates through all the key-value pairs in any table. However, that traversal is done in an undefined order and can vary from run to run.\n\n    \n     \n    \n    \nLua has no defined order for the keys in a general table. This contrasts with the keys in a pure Lua array where the indices are always stored in their natural order from 1 on.\n\nWe supply a counterpart iterator table.ordered_pairs(comparator) that returns an iterator that traverses the keys in the table in a fixed order. By default, keys are sorted by type and then by value, so numeric keys come first in their natural order, and those are followed by the others where strings are sorted alphabetically.\nIf you supply a comparator argument it should take two key arguments k1, k2 and return true if you want k1 to appear before k2.\nExample\nlocal tbl = { frog = 1, badger = 2, eagle = 3 }\n1for k, v in pairs(tbl) do print(k, v) end\nprint(\"--------\")\n\n2local iter = table.ordered_pairs()\nfor k, v in iter(tbl) do print(k, v) end\nprint(\"--------\")\n\n3iter = table.ordered_pairs(\"&gt;\")\nfor k, v in iter(tbl) do print(k, v) end\n\n1\n\nLua’s standard pair method.\n\n2\n\nHere, the ordered_pairs method uses the default key comparator function.\n\n3\n\nHere, the ordered_pairs method uses a custom key comparator “function”.\n\n\noutputs\n1eagle   3\nfrog    1\nbadger  2\n--------\n2badger  2\neagle   3\nfrog    1\n--------\n3frog    1\neagle   3\nbadger  2\n\n1\n\nThe key-value pairs are output in whatever undefined order Lua stores them.\n\n2\n\nThe key-value pairs are output in our default increasing alphabetic order for the keys.\n\n3\n\nThe key-value pairs are output in a custom-decreasing alphabetic order for the keys.\n\n\n\n\nA custom comparator function can come in one of several forms:\n\nYou can use Lua functions like table.ordered_pairs(function(a,b) return a &gt; b end).\nYou can use a string operator like table.ordered_pairs(\"&gt;\").\nYou can use a string {lulu.anon} like table.ordered_pairs(\"|a,b| a &gt; b\").\nYou can pass a “table” that happens to be *callable, i.e., it has a __call() metamethod that takes two items and compares them.\n\nThere is more detail on the second and third options in the documentation for the lulu.callable module."
  },
  {
    "objectID": "pages/table/ordered_pairs.html#table.compareab",
    "href": "pages/table/ordered_pairs.html#table.compareab",
    "title": "Lua Tables — Ordered Iteration",
    "section": "table.compare(a,b)",
    "text": "table.compare(a,b)\nThe table.compare function is the default comparator used by the table.ordered_pairs method. It compares two values a and b by type first and then by value.\nNumeric keys come first and are sorted in natural order. String keys are sorted alphabetically."
  },
  {
    "objectID": "pages/table/ordered_pairs.html#see-also",
    "href": "pages/table/ordered_pairs.html#see-also",
    "title": "Lua Tables — Ordered Iteration",
    "section": "See Also",
    "text": "See Also\ntable.keys  lulu.callable"
  },
  {
    "objectID": "pages/table/index.html",
    "href": "pages/table/index.html",
    "title": "Lua tables — Extensions",
    "section": "",
    "text": "The lulu.table module extends the standard set of Lua table methods with extra functionality for any Lua table.\nIf you have imported the module as\nlocal table = require 'lulu.table'\nThen, you can access many extra methods that work for any Lua table.\nThere are quite a few new methods. In practice, each belongs to a functional group, and we first list them by those groupings. The method names within any group follow a consistent scheme.\nThe complete list of all the module’s methods is also available in alphabetic order.",
    "crumbs": [
      "Home",
      "Extensions: table"
    ]
  },
  {
    "objectID": "pages/table/index.html#introduction",
    "href": "pages/table/index.html#introduction",
    "title": "Lua tables — Extensions",
    "section": "",
    "text": "The lulu.table module extends the standard set of Lua table methods with extra functionality for any Lua table.\nIf you have imported the module as\nlocal table = require 'lulu.table'\nThen, you can access many extra methods that work for any Lua table.\nThere are quite a few new methods. In practice, each belongs to a functional group, and we first list them by those groupings. The method names within any group follow a consistent scheme.\nThe complete list of all the module’s methods is also available in alphabetic order.",
    "crumbs": [
      "Home",
      "Extensions: table"
    ]
  },
  {
    "objectID": "pages/table/index.html#general-queries",
    "href": "pages/table/index.html#general-queries",
    "title": "Lua tables — Extensions",
    "section": "General Queries",
    "text": "General Queries\nThe module has various methods for common queries. In particular, the size method works correctly for general tables.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\ntable.size\nReturns the number of top-level items in any table.\n\n\ntable.is_table\nChecks that the argument is a table. Issues a warning if its not.\n\n\ntable.is_array\nChecks that the argument is a Lua array.\n\n\ntable.is_array_of\nChecks that the argument is a Lua array where all the elements are of the given type.\n\n\ntable.is_array_of_one_type\nChecks that the argument is a Lua array where all the elements are of the same type.\n\n\ntable.is_array_of_numbers\nChecks that the argument is a Lua array where all the elements are numbers.\n\n\ntable.is_array_of_strings\nChecks that the argument is a Lua array where all the elements are strings.\n\n\ntable.metadata\nReturns a table of metadata about a table.",
    "crumbs": [
      "Home",
      "Extensions: table"
    ]
  },
  {
    "objectID": "pages/table/index.html#key-value-queries",
    "href": "pages/table/index.html#key-value-queries",
    "title": "Lua tables — Extensions",
    "section": "Key-Value Queries",
    "text": "Key-Value Queries\nWe have methods to grab all the keys and values in arrays and sets.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\ntable.keys\nReturns the top-level keys from a table as an array, generally sorted in some manner.\n\n\ntable.values\nReturn top-level values from a table as an array, optionally sorted in some manner.\n\n\ntable.counts\nReturns a table of the top-level value counts for each value in a table.\n\n\ntable.set_of_keys\nReturns the set of keys in a table.\n\n\ntable.set_of_values\nReturns the set of values in a table.",
    "crumbs": [
      "Home",
      "Extensions: table"
    ]
  },
  {
    "objectID": "pages/table/index.html#copying-comparing",
    "href": "pages/table/index.html#copying-comparing",
    "title": "Lua tables — Extensions",
    "section": "Copying & Comparing",
    "text": "Copying & Comparing\nAs well as the usual shallow clone method we also supply deep copy and deep comparison methods that can work with complex tables containing cycles and self references.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\ntable.clone\nMake a shallow copy of a table.\n\n\ntable.copy\nMake a deep copy of a table.\n\n\ntable.eq\nDoes a deep comparison between the content of two tables.",
    "crumbs": [
      "Home",
      "Extensions: table"
    ]
  },
  {
    "objectID": "pages/table/index.html#iterating",
    "href": "pages/table/index.html#iterating",
    "title": "Lua tables — Extensions",
    "section": "Iterating",
    "text": "Iterating\nThe order that Lua stores key-value pairs in a general table is not defined and will change from run to run of the same program and data. We supply an iterator maker that can be passed a comparator to order the keys in a fixed manner; it returns an iterator that traverses the keys in that order.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\ntable.compare\nThe default comparison method used to sort a table’s keys.\n\n\ntable.ordered_pairs\nAn iterator that traverses a table in a sorted key order.",
    "crumbs": [
      "Home",
      "Extensions: table"
    ]
  },
  {
    "objectID": "pages/table/index.html#searching",
    "href": "pages/table/index.html#searching",
    "title": "Lua tables — Extensions",
    "section": "Searching",
    "text": "Searching\nWe have methods to look for particular values in a table.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\ntable.find\nFind the key for a top-level value.\n\n\ntable.contains\nReturns true if a top-level value is present in a table.\n\n\ntable.find_if\nFinds a top-level key-value pair where the value is not nil when passed to a predicate function.",
    "crumbs": [
      "Home",
      "Extensions: table"
    ]
  },
  {
    "objectID": "pages/table/index.html#unions-etc.",
    "href": "pages/table/index.html#unions-etc.",
    "title": "Lua tables — Extensions",
    "section": "Unions etc.",
    "text": "Unions etc.\nWe have methods to find elements in common between tables etc. These methods look at both the keys and the values of table elements when considering commonality and differences.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\ntable.union\nReturns the union of two or more tables.\n\n\ntable.intersection\nReturns the intersection of two or more tables.\n\n\ntable.difference\nReturns the difference between two tables.  Optionally can return the symmetric difference.\n\n\ntable.merged_keys\nReturns an array of the merged keys from two or more tables.\n\n\ntable.merged_values\nReturns an array of the merged values from two or more tables.\n\n\ntable.common_keys\nReturns an array of the common keys from two or more tables.\n\n\ntable.common_values\nReturns an array of the common values from two or more tables.\n\n\ntable.unique_keys\nReturns an array of the unique keys from one of two tables.\n\n\ntable.unique_values\nReturns an array of the unique values from one of two tables.",
    "crumbs": [
      "Home",
      "Extensions: table"
    ]
  },
  {
    "objectID": "pages/table/index.html#transforming-mapping",
    "href": "pages/table/index.html#transforming-mapping",
    "title": "Lua tables — Extensions",
    "section": "Transforming & Mapping",
    "text": "Transforming & Mapping\nWe have methods to transform and map over the values in a table.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\ntable.map\nMap a function over the top-level values & return a new table.\n\n\ntable.map2\nMap a function over the top-level values from two tables with identical keys & return a new table.\n\n\ntable.kv_map\nMap a function over the top-level key-value pairs & return a new table.\n\n\ntable.transform\nTransforms a table in place by applying a function to each top-level value.\n\n\n\n\nThe first three of those methods do not alter any passed table argument.",
    "crumbs": [
      "Home",
      "Extensions: table"
    ]
  },
  {
    "objectID": "pages/table/index.html#all-methods",
    "href": "pages/table/index.html#all-methods",
    "title": "Lua tables — Extensions",
    "section": "All Methods",
    "text": "All Methods\nHere is a table of the module methods in alphabetical order.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\ntable.clone\nReturns a shallow copy of a table.\n\n\ntable.common_keys\nReturns the keys that are present in all tables passed as arguments.\n\n\ntable.common_values\nReturns the values that are present in all tables passed as arguments.\n\n\ntable.compare\nThe default comparison method used to sort a table’s keys.\n\n\ntable.contains\nReturns true if a top-level value is present in a table.\n\n\ntable.copy\nReturns a deep copy of a table.\n\n\ntable.counts\nReturns a table of the top-level value counts for each value in tbl.\n\n\ntable.difference\nReturns the difference between two tables.\n\n\ntable.eq\nDoes a deep comparison between the content of two tables.\n\n\ntable.find\nFind the key for a top-level value.\n\n\ntable.find_if\nFinds a top-level key-value pair where the value is not nil when passed to a predicate function.\n\n\ntable.intersection\nReturns the intersection of two or more tables.\n\n\ntable.is_array\nChecks that the argument is a Lua array.\n\n\ntable.is_array_of\nChecks that the argument is a Lua array where all the elements are of a given type.\n\n\ntable.is_array_of_numbers\nChecks that the argument is a Lua array where all the elements are numbers.\n\n\ntable.is_array_of_one_type\nChecks that the argument is a Lua array where all the elements are of the same type.\n\n\ntable.is_array_of_strings\nChecks that the argument is a Lua array where all the elements are strings.\n\n\ntable.is_table\nChecks that the argument is a table.\n\n\ntable.keys\nReturns the top-level keys from a table as an array, generally sorted in some manner.\n\n\ntable.kv_map\nMap a function over the top-level key-value pairs & return a new table.\n\n\ntable.map\nMap a function over the top-level values & return a new table.\n\n\ntable.map2\nMap a function over the top-level values from two tables with identical keys & return a new table.\n\n\ntable.merged_keys\nReturns the merged keys of two or more tables.\n\n\ntable.merged_values\nReturns the merged values of two or more tables.\n\n\ntable.metadata\nReturns a table of metadata about a table.\n\n\ntable.ordered_pairs\nAn iterator that traverses a table in a sorted key order.\n\n\ntable.size\nReturns the number of top-level items in any table.\n\n\ntable.transform\nMap a function over the top-level values & return a new table.\n\n\ntable.union\nReturns the union of two or more tables.\n\n\ntable.unique_keys\nReturns the unique keys in one of two tables.\n\n\ntable.unique_values\nReturns the unique values in one of two tables.\n\n\ntable.values\nReturn top-level values from a table as an array, optionally sorted in some manner.\n\n\ntable.set_of_keys\nReturns the set of keys in a table.\n\n\ntable.set_of_values\nReturns the set of values in a table.",
    "crumbs": [
      "Home",
      "Extensions: table"
    ]
  },
  {
    "objectID": "pages/table/index.html#see-also",
    "href": "pages/table/index.html#see-also",
    "title": "Lua tables — Extensions",
    "section": "See Also",
    "text": "See Also\nLua’s standard table manipulation methods  lulu.Array  lulu.callable",
    "crumbs": [
      "Home",
      "Extensions: table"
    ]
  },
  {
    "objectID": "pages/table/keys-values.html",
    "href": "pages/table/keys-values.html",
    "title": "Lua Tables — Keys and Values",
    "section": "",
    "text": "If you have imported the lulu.table module as\nrequire 'lulu.table'\nthen you have access to the following methods:\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\ntable.keys(tbl, comparator)\nReturns the top-level keys from tbl as an array, generally sorted in some manner.\n\n\ntable.values(tbl, comparator)\nReturn top-level values from tbl as an array, optionally sorted in some manner.\n\n\ntable.counts(tbl)\nReturns a table of the top-level value counts for each value in tbl.\n\n\ntable.set_of_keys(tbl)\nReturns the set of keys in tbl.\n\n\ntable.set_of_values(tbl)\nReturns the set of values in tbl."
  },
  {
    "objectID": "pages/table/keys-values.html#introduction",
    "href": "pages/table/keys-values.html#introduction",
    "title": "Lua Tables — Keys and Values",
    "section": "",
    "text": "If you have imported the lulu.table module as\nrequire 'lulu.table'\nthen you have access to the following methods:\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\ntable.keys(tbl, comparator)\nReturns the top-level keys from tbl as an array, generally sorted in some manner.\n\n\ntable.values(tbl, comparator)\nReturn top-level values from tbl as an array, optionally sorted in some manner.\n\n\ntable.counts(tbl)\nReturns a table of the top-level value counts for each value in tbl.\n\n\ntable.set_of_keys(tbl)\nReturns the set of keys in tbl.\n\n\ntable.set_of_values(tbl)\nReturns the set of values in tbl."
  },
  {
    "objectID": "pages/table/keys-values.html#table.keys",
    "href": "pages/table/keys-values.html#table.keys",
    "title": "Lua Tables — Keys and Values",
    "section": "table.keys",
    "text": "table.keys\nThis method can be given a comparator argument, a function called with two items. It should return true if the first one is considered dominant and false otherwise.\n\n    \n     \n    \n    \nWe supply a default table.compare function used to sort table keys. It sorts the keys by type and value, so numeric keys come first and are sorted in natural order. String keys are sorted alphabetically.\n\nYou can explicitly set the comparator argument to false to disable key sorting. So, table.keys(tbl, false) returns the array of keys in whatever order Lua happened to store them. This is not the same as table.keys(tbl), which returns the array of keys sorted using the default comparator method.\nExample\nlocal tbl = { frog = 1, badger = 2, eagle = 3 }\n1print(table.concat(table.keys(tbl,false), \", \"))\n2print(table.concat(table.keys(tbl),       \", \"))\n\n1\n\nWe explicitly set the comparator argument to false so no sorting is done on the keys.\n\n2\n\nWe passed a single argument here, so the default comparator will be used to sort the keys.\n\n\nThis outputs:\n1frog, eagle, badger\n2badger, eagle, frog\n\n1\n\nThe keys are output in whatever undefined order Lua stores them (varies from run to run).\n\n2\n\nThe keys are output in a fixed, alphabetically sorted, order."
  },
  {
    "objectID": "pages/table/keys-values.html#table.values",
    "href": "pages/table/keys-values.html#table.values",
    "title": "Lua Tables — Keys and Values",
    "section": "table.values",
    "text": "table.values\nLike the keys method above, you can pass the values method a comparator function or the boolean false to disable sorting.\nHowever, in this case, the default for comparator is false, and we return the values in whatever manner Lua stored them.\nExample\nlocal tbl =  {frog = 1, badger = 2, eagle = 3}\nprint(table.concat(table.values(tbl,false), \", \"))\nprint(table.concat(table.values(tbl),       \", \"))\nprint(table.concat(table.values(tbl, \"&lt;\"),  \", \"))\noutputs:\n13, 2, 1\n23, 2, 1\n31, 2, 3\n\n1\n\nThe values are output in whatever undefined order Lua stores them (this can vary from run to run).\n\n2\n\nThis is the same result because the default value for the comparator argument is false.\n\n3\n\nThe values are sorted using a custom comparator, as described below."
  },
  {
    "objectID": "pages/table/keys-values.html#table.counts",
    "href": "pages/table/keys-values.html#table.counts",
    "title": "Lua Tables — Keys and Values",
    "section": "table.counts",
    "text": "table.counts\nSometimes, you need to see whether a table has duplicated values.\nExample\nlocal tbl =  {frog = \"kermit\", badger = \"kermit\", eagle = \"eddie\"}\nlocal counts = table.counts(tbl)\nfor k,v in pairs(counts) do print(k,v) end\noutputs:\neddie   1\nkermit  2"
  },
  {
    "objectID": "pages/table/keys-values.html#table.set_of_keys",
    "href": "pages/table/keys-values.html#table.set_of_keys",
    "title": "Lua Tables — Keys and Values",
    "section": "table.set_of_keys",
    "text": "table.set_of_keys\nThis method returns a table where the keys are the values in tbl with corresponding value true.\nExample\nlocal tbl =  {frog = \"kermit\", badger = \"kermit\", eagle = \"eddie\"}\nlocal key_set = table.set_of_keys(tbl)\nfor k in pairs(key_set) do print(k) end\noutputs:\nbadger\neagle\nfrog"
  },
  {
    "objectID": "pages/table/keys-values.html#table.set_of_values",
    "href": "pages/table/keys-values.html#table.set_of_values",
    "title": "Lua Tables — Keys and Values",
    "section": "table.set_of_values",
    "text": "table.set_of_values\nThis method returns a table where the values are the values in tbl with corresponding value true.\nExample\nlocal tbl =  {frog = \"kermit\", badger = \"kermit\", eagle = \"eddie\"}\nlocal value_set = table.set_of_values(tbl)\nfor v in pairs(value_set) do print(v) end\noutputs:\neddie\nkermit\n\nComparator Functions\nA custom comparator function can come in one of several forms:\n\nYou can use Lua function like table.keys(tbl, function(a,b) return a &gt; b end).\nYou can use a string operator like table.keys(tbl, \"&gt;\", 0).\nYou can use a string lambda like table.keys(tbl, \"|a,b| a &gt; b\").\nYou can pass a “table” that happens to be callable i.e. has a __call() metamethod that takes two items and does a comparison.\n\nThere is more detail on the second and third options in the documentation for the lulu.callable module."
  },
  {
    "objectID": "pages/table/keys-values.html#see-also",
    "href": "pages/table/keys-values.html#see-also",
    "title": "Lua Tables — Keys and Values",
    "section": "See Also",
    "text": "See Also\ntable.ordered_pairs  lulu.callable"
  },
  {
    "objectID": "pages/messages/index.html",
    "href": "pages/messages/index.html",
    "title": "Error and Warning Messages",
    "section": "",
    "text": "The lulu.messages module has functions for emitting informational, warning, and fatal error messages. These are used throughout lulu.\nMessages can have arbitrary payloads and are generally decorated with a tag of some sort (a string like INFO, WARNING, or FATAL ERROR) and the source code location where the message was emitted.",
    "crumbs": [
      "Home",
      "Messages"
    ]
  },
  {
    "objectID": "pages/messages/index.html#introduction",
    "href": "pages/messages/index.html#introduction",
    "title": "Error and Warning Messages",
    "section": "",
    "text": "The lulu.messages module has functions for emitting informational, warning, and fatal error messages. These are used throughout lulu.\nMessages can have arbitrary payloads and are generally decorated with a tag of some sort (a string like INFO, WARNING, or FATAL ERROR) and the source code location where the message was emitted.",
    "crumbs": [
      "Home",
      "Messages"
    ]
  },
  {
    "objectID": "pages/messages/index.html#methods",
    "href": "pages/messages/index.html#methods",
    "title": "Error and Warning Messages",
    "section": "Methods",
    "text": "Methods\nIf you have imported the module as\nlocal msg = require 'lulu.messages'\nthen you have access to the following methods:\n\n\n\n\n\n\n\nModule Function\nDescription\n\n\n\n\nmsg.message(arg, ...)\nPrints a message to stdout without any tag but with source location information.\n\n\nmsg.info(arg, ...)\nPrints a message to stdout decorated with an “INFO” tag and source location information.\n\n\nmsg.warn(arg, ...)\nPrints a message to stdout decorated with a “WARNING” tag and source location information.\n\n\nmsg.fatal(arg, ...)\nPrints prominent fatal error message to stderr and then exits the program.\n\n\nmsg.source_info(offset)\nReturns the function name, file basename, and the line number of the corresponding Lua stack location.\n\n\n: {.bordered .striped .hover .responsive tbl-colwidths=“[25,75]”}\n\n\n\n\nThe purpose of the first four methods above is obvious. The source_info method is discussed in more detail below.",
    "crumbs": [
      "Home",
      "Messages"
    ]
  },
  {
    "objectID": "pages/messages/index.html#sample-outputs",
    "href": "pages/messages/index.html#sample-outputs",
    "title": "Error and Warning Messages",
    "section": "Sample Outputs",
    "text": "Sample Outputs\nGiven a file test.lua with the following Lua code:\nlocal msg = require 'lulu.messages'\nlocal function test_message(x) msg.message(\"x = %d\", x)  end\nlocal function test_info(x)    msg.info(\"x = %d\", x)     end\nlocal function test_warn(x)    msg.warn(\"x = %d\", x)     end\nlocal function test_fatal(x)   msg.fatal(\"x = %d\", x)    end\nAdding a line test_message(42) to that file will give the output:\n'test_message' (test.lua:2): x = 42\nChanging that to test_info(42) yields\n[INFO] from 'test_info' (test.lua:3): x = 42\nChanging that to test_warn(42) yields\n[WARNING] from 'test_info' (test.lua:4): x = 42\nFinally, changing that to test_fatal(42) yields a more prominent message on stderr\n===================================================================================================\n[FATAL ERROR] from 'test_fatal' (test.lua:5): x = 42\nThe program will now exit ...\n===================================================================================================\nA program exit follows this.\n\n    \n     \n    \n    \nThe source code location is the filename, followed by a colon :, and then a line number within the file (e.g. test.lua:5) Our source_info method strips the full file path to the basename only as this is generally adequate for tracing purposes, and printing the full path often overwhelms the valuable content in the message payload.",
    "crumbs": [
      "Home",
      "Messages"
    ]
  },
  {
    "objectID": "pages/messages/index.html#library-usage",
    "href": "pages/messages/index.html#library-usage",
    "title": "Error and Warning Messages",
    "section": "Library Usage",
    "text": "Library Usage\nIf you’re writing a library, it is often helpful to have the source code location of the error point up the stack to where the library user made an erroneous call. While the error is detected in a library function, it is often the caller of that function you want to highlight to the user.\nThis is best illustrated with an example.\nSuppose we have the following incredibly clever and important library function in a file called double.lua:\nlocal messages = require(\"messages\")\nlocal function double(x)\n    if type(x) ~= 'number' then\n        messages.warn(\"Expected arg to be a number not a '%s'\", type(x))\n        return nil\n    end\n    return 2*x\nend\nreturn double\nThe library has a function that takes a number and returns the double of that number. It also checks that the argument passed to the function is indeed a number and raises a warning if it is not (we’re ignoring Lua’s ability to turn some strings into numbers here).\nHere is a program main.lua that calls that function:\nlocal putln = require('scribe').putln\nlocal double = require('double')\nlocal x = 42\nlocal y = double(x)\nif y then putln(\"2*%d = %d\", x, y) end\nWhen run, this prints the line “2*42 = 84” to your screen.\nSuppose we had a typo in main.lua and replaced the line local x = 42 with local x = 'hallo'. Then, when we run the program, we will get the warning message:\n[WARNING] from 'double' (double.lua:4): Expected arg to be a number not a 'string'\nThe message is clear, but the source code location information (double.lua:4) points to a file and line number inside our library, which is the location where the error was detected. It would be preferable to point instead to the source code location where the library’s caller made the error.\nThe messages module makes this easy!\nAll the message methods can be given an extra numeric first argument that tells source_info method to grab the appropriate location information from a point further up the Lau stack.\nThe designer of the ambitious double library can write the very slightly different code:\nlocal messages = require(\"messages\")\nlocal function double(x)\n    if type(x) ~= 'number' then\n        messages.warn(1, \"Expected arg to be a number not a '%s'\", type(x))\n        return nil\n    end\n    return 2*x\nend\nreturn double\nwhere you should note that extra first argument in the messages.warn(1, ...) call.\nNow, if the user’s code is in main.lua looks like\nlocal putln = require('scribe').putln\nlocal double = require('double')\nlocal x = 'hallo'\nlocal y = double(x)\nif y then putln(\"2*%d = %d\", x, y) end\nThen, on running, the following error message appears:\n[WARNING] from 'main' (main.lua:4): Expected arg to be a number not a 'string'\nThe payload for the warning message has not changed, but the source of the error now clearly points to the point (line 4 of main.lua) where the user called the library function incorrectly.\n\n    \n     \n    \n    \nThe module’s source_info method makes use of Lua’s introspection facilities and, in particular, debug.getinfo. That standard library function takes a stack location as its first argument.",
    "crumbs": [
      "Home",
      "Messages"
    ]
  },
  {
    "objectID": "pages/messages/index.html#see-also",
    "href": "pages/messages/index.html#see-also",
    "title": "Error and Warning Messages",
    "section": "See Also",
    "text": "See Also\nlulu.scribe  lulu.paths",
    "crumbs": [
      "Home",
      "Messages"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The lulu Library",
    "section": "",
    "text": "lulu is a collection of Lua utility modules and classes. It includes a full-featured Array class, an Enum class, and a variety of other utility functions and extensions.\nIt also includes a copy of Scribe, a Lua module for converting Lua objects to strings that can gracefully handle recursive and shared tables."
  },
  {
    "objectID": "index.html#project-overview",
    "href": "index.html#project-overview",
    "title": "The lulu Library",
    "section": "",
    "text": "lulu is a collection of Lua utility modules and classes. It includes a full-featured Array class, an Enum class, and a variety of other utility functions and extensions.\nIt also includes a copy of Scribe, a Lua module for converting Lua objects to strings that can gracefully handle recursive and shared tables."
  },
  {
    "objectID": "index.html#available-modules",
    "href": "index.html#available-modules",
    "title": "The lulu Library",
    "section": "Available Modules",
    "text": "Available Modules\n\n\n\n\n\n\n\n\nModule\nPurpose\n\n\n\n\nlulu.Array\nA full-featured Array class for Lua.\n\n\nlulu.Enum\nAn Enum class for Lua.\n\n\nlulu.callable\nBuilding “anonymous” functions from strings etc.\n\n\nlulu.messages\nInformational and error messages used throughout lulu.\n\n\nlulu.scribe\nConvert Lua objects to strings. Gracefully handles recursive and shared tables.\n\n\nlulu.table\nLua table extensions that work on any table.\n\n\nlulu.string\nLua string extensions that are added to all string objects.\n\n\nlulu.xpeg\nAn extended lpeg module with predefined patterns and useful functions.\n\n\nlulu.paths\nRudimentary path query methods.\n\n\nlulu.types\nType-checking methods."
  },
  {
    "objectID": "index.html#installation-use",
    "href": "index.html#installation-use",
    "title": "The lulu Library",
    "section": "Installation & Use",
    "text": "Installation & Use\nlulu has no dependencies. Copy the lulu directory and start using it.\nReleased versions will also be uploaded to the luarocks repository, so you should be able to install them using:\nluarocks install lulu"
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "The lulu Library",
    "section": "Usage",
    "text": "Usage\nAssuming your path allows it, you can require('lulu.lulu') and have access to all the modules:\nrequire('lulu.lulu')\nlocal Suit = Enum {\n    Clubs    = { abbrev = 'C', color = 'black', icon = '♣', ordinal = 0 },\n    Diamonds = { abbrev = 'D', color = 'red',   icon = '♦', ordinal = 1 },\n    Hearts   = { abbrev = 'H', color = 'red',   icon = '♥', ordinal = 2 },\n    Spades   = { abbrev = 'S', color = 'black', icon = '♠', ordinal = 3 }\n}\nSuit:set_type('Suit')\nscribe.putln(\"%T\", Suit)\nThat will output:\nSuit:\n [0] Clubs = { abbrev = \"C\", color = \"black\", icon = \"♣\" },\n [1] Diamonds = { abbrev = \"D\", color = \"red\", icon = \"♦\" },\n [2] Hearts = { abbrev = \"H\", color = \"red\", icon = \"♥\" },\n [3] Spades = { abbrev = \"S\", color = \"black\", icon = \"♠\" }\nAlternatively, you can access the modules individually:\nlocal scribe = require('lulu.scribe')\nlocal Array  = require('lulu.Array')\nlocal arr = Array:new({1, 2, 3})\narr:transform(\"*\", 10)\nscribe.putln(\"%t\", arr)\nThis will output:\n[ 10, 20, 30 ]"
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "The lulu Library",
    "section": "Documentation",
    "text": "Documentation\nHere is a link to the project’s source code repository.  This documentation site was constructed using the static website generator Quarto."
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "The lulu Library",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThis library owes a lot to {Penlight} and the many questions that have been answered over the years on sites like StackOverflow and Reddit."
  },
  {
    "objectID": "index.html#contact",
    "href": "index.html#contact",
    "title": "The lulu Library",
    "section": "Contact",
    "text": "Contact\nYou can contact me by email"
  },
  {
    "objectID": "index.html#copyright-and-license",
    "href": "index.html#copyright-and-license",
    "title": "The lulu Library",
    "section": "Copyright and License",
    "text": "Copyright and License\nCopyright (c) 2025-present Nessan Fitzmaurice.  You can use this software under the MIT License"
  },
  {
    "objectID": "pages/index.html",
    "href": "pages/index.html",
    "title": "The lulu Library",
    "section": "",
    "text": "lulu is a collection of Lua utility modules and classes. It includes a full-featured Array class, an Enum class, and a variety of other utility functions and extensions.\nIt also includes a copy of Scribe, a Lua module for converting Lua objects to strings that can gracefully handle recursive and shared tables.",
    "crumbs": [
      "Home",
      "Library Overview"
    ]
  },
  {
    "objectID": "pages/index.html#project-overview",
    "href": "pages/index.html#project-overview",
    "title": "The lulu Library",
    "section": "",
    "text": "lulu is a collection of Lua utility modules and classes. It includes a full-featured Array class, an Enum class, and a variety of other utility functions and extensions.\nIt also includes a copy of Scribe, a Lua module for converting Lua objects to strings that can gracefully handle recursive and shared tables.",
    "crumbs": [
      "Home",
      "Library Overview"
    ]
  },
  {
    "objectID": "pages/index.html#available-modules",
    "href": "pages/index.html#available-modules",
    "title": "The lulu Library",
    "section": "Available Modules",
    "text": "Available Modules\n\n\n\n\n\n\n\n\nModule\nPurpose\n\n\n\n\nlulu.Array\nA full-featured Array class for Lua.\n\n\nlulu.Enum\nAn Enum class for Lua.\n\n\nlulu.callable\nBuilding “anonymous” functions from strings etc.\n\n\nlulu.messages\nInformational and error messages used throughout lulu.\n\n\nlulu.scribe\nConvert Lua objects to strings. Gracefully handles recursive and shared tables.\n\n\nlulu.table\nLua table extensions that work on any table.\n\n\nlulu.string\nLua string extensions that are added to all string objects.\n\n\nlulu.xpeg\nAn extended lpeg module with predefined patterns and useful functions.\n\n\nlulu.paths\nRudimentary path query methods.\n\n\nlulu.types\nType-checking methods.",
    "crumbs": [
      "Home",
      "Library Overview"
    ]
  },
  {
    "objectID": "pages/index.html#installation-use",
    "href": "pages/index.html#installation-use",
    "title": "The lulu Library",
    "section": "Installation & Use",
    "text": "Installation & Use\nlulu has no dependencies. Copy the lulu directory and start using it.\nReleased versions will also be uploaded to the luarocks repository, so you should be able to install them using:\nluarocks install lulu",
    "crumbs": [
      "Home",
      "Library Overview"
    ]
  },
  {
    "objectID": "pages/index.html#usage",
    "href": "pages/index.html#usage",
    "title": "The lulu Library",
    "section": "Usage",
    "text": "Usage\nAssuming your path allows it, you can require('lulu.lulu') and have access to all the modules:\nrequire('lulu.lulu')\nlocal Suit = Enum {\n    Clubs    = { abbrev = 'C', color = 'black', icon = '♣', ordinal = 0 },\n    Diamonds = { abbrev = 'D', color = 'red',   icon = '♦', ordinal = 1 },\n    Hearts   = { abbrev = 'H', color = 'red',   icon = '♥', ordinal = 2 },\n    Spades   = { abbrev = 'S', color = 'black', icon = '♠', ordinal = 3 }\n}\nSuit:set_type('Suit')\nscribe.putln(\"%T\", Suit)\nThat will output:\nSuit:\n [0] Clubs = { abbrev = \"C\", color = \"black\", icon = \"♣\" },\n [1] Diamonds = { abbrev = \"D\", color = \"red\", icon = \"♦\" },\n [2] Hearts = { abbrev = \"H\", color = \"red\", icon = \"♥\" },\n [3] Spades = { abbrev = \"S\", color = \"black\", icon = \"♠\" }\nAlternatively, you can access the modules individually:\nlocal scribe = require('lulu.scribe')\nlocal Array  = require('lulu.Array')\nlocal arr = Array:new({1, 2, 3})\narr:transform(\"*\", 10)\nscribe.putln(\"%t\", arr)\nThis will output:\n[ 10, 20, 30 ]",
    "crumbs": [
      "Home",
      "Library Overview"
    ]
  },
  {
    "objectID": "pages/index.html#documentation",
    "href": "pages/index.html#documentation",
    "title": "The lulu Library",
    "section": "Documentation",
    "text": "Documentation\nHere is a link to the project’s source code repository.  This documentation site was constructed using the static website generator Quarto.",
    "crumbs": [
      "Home",
      "Library Overview"
    ]
  },
  {
    "objectID": "pages/index.html#acknowledgements",
    "href": "pages/index.html#acknowledgements",
    "title": "The lulu Library",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThis library owes a lot to {Penlight} and the many questions that have been answered over the years on sites like StackOverflow and Reddit.",
    "crumbs": [
      "Home",
      "Library Overview"
    ]
  },
  {
    "objectID": "pages/index.html#contact",
    "href": "pages/index.html#contact",
    "title": "The lulu Library",
    "section": "Contact",
    "text": "Contact\nYou can contact me by email",
    "crumbs": [
      "Home",
      "Library Overview"
    ]
  },
  {
    "objectID": "pages/index.html#copyright-and-license",
    "href": "pages/index.html#copyright-and-license",
    "title": "The lulu Library",
    "section": "Copyright and License",
    "text": "Copyright and License\nCopyright (c) 2025-present Nessan Fitzmaurice.  You can use this software under the MIT License",
    "crumbs": [
      "Home",
      "Library Overview"
    ]
  },
  {
    "objectID": "pages/table/queries.html",
    "href": "pages/table/queries.html",
    "title": "Lua Tables — Queries",
    "section": "",
    "text": "If you have imported the module as\nthen you have access to the following query methods:"
  },
  {
    "objectID": "pages/table/queries.html#metadata",
    "href": "pages/table/queries.html#metadata",
    "title": "Lua Tables — Queries",
    "section": "Metadata",
    "text": "Metadata\nThe table.metadata(tbl) function returns a table of metadata about a table tbl.\nThe returned table, md, has a sub-table md[t] for each sub-table t encountered in tbl including tbl itself.\nThe md[t] sub-table has the following fields:\n\n\n\n\n\n\n\n\nField\nDescription\n\n\n\n\nmd[t].array\nBoolean that is true if t is a Lua array.\n\n\nmd[t].size\nNumber of elements in t.\n\n\nmd[t].subs\nNumber of proper sub-tables in t.\n\n\nmd[t].refs\nNumber of references to t. Greater than 1 if t is shared.\n\n\n\n\nThis metadata is useful for understanding the structure of a table. The metadata function can handle tables that contain circular references."
  },
  {
    "objectID": "pages/table/queries.html#see-also",
    "href": "pages/table/queries.html#see-also",
    "title": "Lua Tables — Queries",
    "section": "See Also",
    "text": "See Also\ntable.keys  table.values  {table.value_counts}  {table.key_set}  {table.value_set}"
  },
  {
    "objectID": "pages/table/eq.html",
    "href": "pages/table/eq.html",
    "title": "Lua Tables — Equality Checking",
    "section": "",
    "text": "Lua has a standard value-based equality check for all its simple types. This means lhs == rhs works precisely as you’d expect if lhs and rhs are both numbers.\nLua’s default notion of equality for other types is reference equality, which checks that two items point to the memory location. This means that\nlocal a1, a2 = { 1,2,3 }, { 1,2,3 }\nputln(\"%t == %t returned: %s\", a1, a2, a1 == a2)\noutputs [ 1, 2, 3 ] == [ 1, 2, 3 ] returned: false.\nDespite having identical content, the two arrays occupy separate memory regions. Lua is just checking whether the addresses for a1 and a2 are the same, which they are not.\nHowever, Lua’s string implementation ensures that a reference equality check works fine for those:\nlocal s1, s2 = 'Hallo', 'Hallo'\nputln(\"%q == %q returned: %s\", s1, s2, s1 == s2)\noutputs \"Hallo\" == \"Hallo\" returned: true.\nAlthough it looks like you created two separate strings, s1 and s2, Lua made a singleton behind the scenes and pointed the two values, s1 and s2, to the same backing store.\nThis behaviour is unique to strings. Lua never does this for tables,\n\n    \n     \n    \n    \nThe examples on this page use scribe.putln for formatted printing."
  },
  {
    "objectID": "pages/table/eq.html#introduction",
    "href": "pages/table/eq.html#introduction",
    "title": "Lua Tables — Equality Checking",
    "section": "",
    "text": "Lua has a standard value-based equality check for all its simple types. This means lhs == rhs works precisely as you’d expect if lhs and rhs are both numbers.\nLua’s default notion of equality for other types is reference equality, which checks that two items point to the memory location. This means that\nlocal a1, a2 = { 1,2,3 }, { 1,2,3 }\nputln(\"%t == %t returned: %s\", a1, a2, a1 == a2)\noutputs [ 1, 2, 3 ] == [ 1, 2, 3 ] returned: false.\nDespite having identical content, the two arrays occupy separate memory regions. Lua is just checking whether the addresses for a1 and a2 are the same, which they are not.\nHowever, Lua’s string implementation ensures that a reference equality check works fine for those:\nlocal s1, s2 = 'Hallo', 'Hallo'\nputln(\"%q == %q returned: %s\", s1, s2, s1 == s2)\noutputs \"Hallo\" == \"Hallo\" returned: true.\nAlthough it looks like you created two separate strings, s1 and s2, Lua made a singleton behind the scenes and pointed the two values, s1 and s2, to the same backing store.\nThis behaviour is unique to strings. Lua never does this for tables,\n\n    \n     \n    \n    \nThe examples on this page use scribe.putln for formatted printing."
  },
  {
    "objectID": "pages/table/eq.html#the-table.eq-function",
    "href": "pages/table/eq.html#the-table.eq-function",
    "title": "Lua Tables — Equality Checking",
    "section": "The table.eq Function",
    "text": "The table.eq Function\nIf you have imported the lulu.table module as\nrequire 'lulu.table'\nthen, you can check for content equality between any two Lua objects, o1 and o2:\ntable.eq(o1,o2,compare_mt)  Returns true if o1 & o2 are identical in content.\nIn this function, o1 and o2 can be any Lua objects. If they are tables, we do a deep comparison for nested elements and will handle recursive tables, tables with self-references, and tables with keys that are tables themselves.\nThe final boolean argument defaults to true. It determines whether we require table objects to have the same metatable. More details are provided below."
  },
  {
    "objectID": "pages/table/eq.html#simple-examples",
    "href": "pages/table/eq.html#simple-examples",
    "title": "Lua Tables — Equality Checking",
    "section": "Simple Examples",
    "text": "Simple Examples\nFor that first array example above:\nputln(\"table.eq(%t,%t) returned: %s\", a1, a2, table.eq(a1,a2))\noutputs table.eq([ 1, 2, 3 ],[ 1, 2, 3 ]) returned: true, which is likely what you would naively expect.\nOf course, for arrays like a1 and a2, where the elements are simple, it is easy to check the contents are identical. The two arrays need the same length, and you can iterate through them to check that the elements are equal.\nHowever, even for simple tables like\nlocal t1, t2 = {first='Alice',last='Smith'}, {first='Alice',last='Smith'}\none has to do some more work to compare the contents. Lua does not standardise the order in which key-value pairs are stored in general tables, so even a trivial example like this one requires some care.\nFor this example, once again, print(t1==t2) returns false, while our function print(table.eq(t1,t2)) will “correctly” return true."
  },
  {
    "objectID": "pages/table/eq.html#complex-examples",
    "href": "pages/table/eq.html#complex-examples",
    "title": "Lua Tables — Equality Checking",
    "section": "Complex Examples",
    "text": "Complex Examples\nNested tables\nlocal t1 = {p1 = {name = 'Alice'}, p2 = {name = 'Beth'}}\nlocal t2 = {p2 = {name = 'Beth'}, p1 = {name = 'Alice'}}\nputln(\"t1: %t\", t1)\nputln(\"t2: %t\", t2)\nputln(\"table.eq(t1, t2) returned: %s\", table.eq(t1,t2))\noutputs:\nt1: { p1 = { name = \"Alice\" }, p2 = { name = \"Beth\" } }\nt2: { p1 = { name = \"Alice\" }, p2 = { name = \"Beth\" } }\ntable.eq(t1, t2) returned: true\nRecursive tables\nlocal t1 = {p1 = {name = 'Alice'}, p2 = {name = 'Beth'}}\nlocal t2 = {p2 = {name = 'Beth'}, p1 = {name = 'Alice'}}\nt1.p1.next = t1.p2\nt1.p2.prev = t1.p1\nt2.p1.next = t2.p2\nt2.p2.prev = t2.p1\nputln(\"t1: %t\", t1)\nputln(\"t2: %t\", t2)\nputln(\"table.eq(t1, t2) returned: %s\", table.eq(t1, t2))\noutputs:\nt1: { p1 = { name = \"Alice\", next = &lt;p2&gt; }, p2 = { name = \"Beth\", prev = &lt;p1&gt; } }\nt2: { p1 = { name = \"Alice\", next = &lt;p2&gt; }, p2 = { name = \"Beth\", prev = &lt;p1&gt; } }\ntable.eq(t1, t2) returned: true\nRecursive tables with a self reference\nlocal t1 = {p1 = {name = 'Alice'}, p2 = {name = 'Beth'}}\nlocal t2 = {p2 = {name = 'Beth'}, p1 = {name = 'Alice'}}\nt1.p1.next = t1.p2\nt1.p2.prev = t1.p1\nt2.p1.next = t2.p2\nt2.p2.prev = t2.p1\nt1.all = t1\nt2.all = t2\nputln(\"t1: %t\", t1)\nputln(\"t2: %t\", t2)\nputln(\"table.eq(t1, t2) returned: %s\", table.eq(t1,t2))\noutputs:\nt1: &lt;table&gt; = { all = &lt;table&gt;, p1 = { name = \"Alice\", next = &lt;p2&gt; }, p2 = { name = \"Beth\", prev = &lt;p1&gt; } }\nt2: &lt;table&gt; = { all = &lt;table&gt;, p1 = { name = \"Alice\", next = &lt;p2&gt; }, p2 = { name = \"Beth\", prev = &lt;p1&gt; } }\ntable.eq(t1, t2) returned: true\nTable with keys that are tables\nlocal t1 = {p1 = {name = 'Alice'}, p2 = {name = 'Beth'}}\nlocal t2 = {p2 = {name = 'Beth'}, p1 = {name = 'Alice'}}\nt1[{}] = \"hidden data\"\nt2[{}] = \"hidden data\"\nputln(\"t1: %t\", t1)\nputln(\"t2: %t\", t2)\nputln(\"table.eq(t1,t2) returned: %s\", table.eq(t1,t2))\noutputs:\nt1: { p1 = { name = \"Alice\" }, p2 = { name = \"Beth\" }, table: 0x600001792d80 = \"hidden data\" }\nt2: { p1 = { name = \"Alice\" }, p2 = { name = \"Beth\" }, table: 0x600001792dc0 = \"hidden data\" }\ntable.eq(t1,t2) returned: true\n\n    \n     \n    \n    \nThis “trick” of using an empty table as a key is quite common in Lua. It allows one to add “hidden” key-value pairs to user data, avoiding potential key duplication clashes. As you can see in the example output, the two table keys are at different addresses. This is irrelevant as we compare the content of those tables. They are both empty, so they match!"
  },
  {
    "objectID": "pages/table/eq.html#metatables",
    "href": "pages/table/eq.html#metatables",
    "title": "Lua Tables — Equality Checking",
    "section": "Metatables",
    "text": "Metatables\nBy default, if the two incoming tables have metatables, the table.eq function will check that they are the same. Of course, in many cases, your tables will not have metatables, so this does not apply.\nIf a metatable contains a __.eq metamethod, then, by default, the tables will be compared using that method.\nHowever, you may want to define a __.eq metamethod for a class using table.eq. This will cause an infinite recursion problem that needs to be avoided. The solution is to set the optional boolean parameter compare_mt to false.\nThis is the route used by the lulu.Array class."
  },
  {
    "objectID": "pages/table/eq.html#see-also",
    "href": "pages/table/eq.html#see-also",
    "title": "Lua Tables — Equality Checking",
    "section": "See Also",
    "text": "See Also\ntable.copy  table.clone  lulu.Array  lulu.scribe"
  },
  {
    "objectID": "pages/table/map.html",
    "href": "pages/table/map.html",
    "title": "Lua Tables — Mapping & Transforming",
    "section": "",
    "text": "If you have imported the lulu.table module as\nrequire 'lulu.table'\nthen you have access to the following methods:\ntable.map(tbl,fun,...)  Returns a new table, which results from applying fun to each value in a table.\ntable.map2(tbl1,tbl2,fun,...)  Returns a new table that results from applying fun to the values from two tables.\ntable.kv_map(tbl,fun,...)  Returns a new table, which results from applying fun to a table’s keys and values.\ntable.transform(tbl,fun,...)  Transform a table in place by applying fun to each top-level value. This method returns the transformed tbl and is ready for further processing."
  },
  {
    "objectID": "pages/table/map.html#introduction",
    "href": "pages/table/map.html#introduction",
    "title": "Lua Tables — Mapping & Transforming",
    "section": "",
    "text": "If you have imported the lulu.table module as\nrequire 'lulu.table'\nthen you have access to the following methods:\ntable.map(tbl,fun,...)  Returns a new table, which results from applying fun to each value in a table.\ntable.map2(tbl1,tbl2,fun,...)  Returns a new table that results from applying fun to the values from two tables.\ntable.kv_map(tbl,fun,...)  Returns a new table, which results from applying fun to a table’s keys and values.\ntable.transform(tbl,fun,...)  Transform a table in place by applying fun to each top-level value. This method returns the transformed tbl and is ready for further processing."
  },
  {
    "objectID": "pages/table/map.html#table.map",
    "href": "pages/table/map.html#table.map",
    "title": "Lua Tables — Mapping & Transforming",
    "section": "table.map",
    "text": "table.map\nClassic “functional” method that creates a new table by applying fun to each value in tbl.\nIn this implementation, the function also passes any extra arguments in the call to table.map(tbl,fun,...).\nIf the returned table is the result, then for each key-value pair k,v in tbl, we set:\nresult[k] = fun(v,...)\nOf course, fun may ignore those extra arguments entirely, and Lua is happy to call a function with multiple arguments, even if it only uses the first one.\nExample:\nlocal lower = {warn = 'warning', note = 'notice', tip = 'hint'}\nlocal upper = table.map(lower, string.upper)\n1putln(\"lower: %t\", lower)\nputln(\"upper: %t\", upper)\n\n1\n\nThe examples on this page use {format.putln} for formatted printing.\n\n\nOutput:\nlower: {['note'] = \"note\", ['tip'] = \"tip\", ['warn'] = \"warning\"}\n1upper: {['note'] = \"NOTE\", ['tip'] = \"TIP\", ['warn'] = \"WARNING\"}\n\n1\n\nWe mapped the Lua standard string.upper(...) method over every value in the lower table."
  },
  {
    "objectID": "pages/table/map.html#table.map2",
    "href": "pages/table/map.html#table.map2",
    "title": "Lua Tables — Mapping & Transforming",
    "section": "table.map2",
    "text": "table.map2\nCreates a new table by applying fun to pairs of values taken from two input tables. table.map2(tbl1,tbl2,fun,....) iterates through the keys k in tbl1 and if there is a corresponding key in tbl2 then it sets:\nresult[k] = fun(tbl1[k],tbl2[k],...).\nNote that the method skips past any keys that are not present in both the input tables.\nExample:\nlocal phone = {mary = '888-888-8888', phil = '888-888-9999'}\nlocal email = {mary = 'mary@gmail.com', phil = 'phil@gmail.com'}\nlocal combined = table.map2(phone, email,\n                        function(v1,v2) return {phone=v1, email=v2} end)\nputln(\"phone:    %t\", phone)\nputln(\"email:    %t\", email)\nputln(\"combined: %t\", combined)\nOutput:\nphone:    {['mary'] = \"888-888-8888\", ['phil'] = \"888-888-9999\"}\nemail:    {['mary'] = \"mary@gmail.com\", ['phil'] = \"phil@gmail.com\"}\ncombined: {['mary'] = {['email'] = \"mary@gmail.com\", ['phone'] = \"888-888-8888\"},\n           ['phil'] = {['email'] = \"phil@gmail.com\", ['phone'] = \"888-888-9999\"}}"
  },
  {
    "objectID": "pages/table/map.html#table.kv_map",
    "href": "pages/table/map.html#table.kv_map",
    "title": "Lua Tables — Mapping & Transforming",
    "section": "table.kv_map",
    "text": "table.kv_map\nFor this method, fun is called with at least two arguments. At its simplest, it is similar to the map function above, and for every key-value pair in tbl it sets:\nresult[k] = fun(k,v,...)\nThis means that fun can do something different depending on k. Here is an example that uses that feature:\nExample: kv_map with a single output\nlocal lower = {warn = 'warning', note = 'notice', tip = 'hint'}\nlocal upper = table.map(lower,\n1                    function(v) return v == 'notice' and \"CAREFUL!\" or v:upper() end)\nputln(\"lower: %t\", lower)\nputln(\"upper: %t\", upper)\n\n1\n\nHere, we do something special for the notice key.\n\n\nOutput:\nlower: {['note'] = \"notice\", ['tip'] = \"hint\", ['warn'] = \"warning\"}\nupper: {['note'] = \"CAREFUL!\", ['tip'] = \"HINT\", ['warn'] = \"WARNING\"}\nPerhaps more interestingly, the kv_map method can optionally return two outputs. If it does, we interpret the first as a key and the second as a value for the result table.\nlocal rk, rv = fun(k,v,...)\nresult[rk] = rv\nThis can be very powerful.\nExample: kv_map with two outputs\nlocal original = {warn = 'warning', note = 'notice', tip = 'hint'}\n1local reversed = table.kv_map(original, \"|k,v| v,k\")\nputln(\"original: %t\", original)\nputln(\"reversed: %t\", reversed)\n\n1\n\nThis string lambda \"|k,v| v,k\" reverses the key and value and returns both.\n\n\nOutput:\noriginal: {['note'] = \"notice\", ['tip'] = \"hint\", ['warn'] = \"warning\"}\n1reversed: {['hint'] = \"tip\", ['notice'] = \"note\", ['warning'] = \"warn\"}\n\n1\n\nEvery key-value pair in original is now a value-key pair in reversed."
  },
  {
    "objectID": "pages/table/map.html#table.transform",
    "href": "pages/table/map.html#table.transform",
    "title": "Lua Tables — Mapping & Transforming",
    "section": "table.transform",
    "text": "table.transform\nThis method is like map above except that it works in place, so for each key-value pair k,v in tbl, we set:\ntbl[k] = fun(v,...)\nExample:\nlocal admonitions = {warn = 'warning', note = 'notice', tip = 'hint'}\nputln(\"admonitions: %t\", admonitions)\ntable.transform(admonitions, string.upper)\nputln(\"admonitions: %t\", admonitions)\nOutput:\nadmonitions: {['note'] = \"notice\", ['tip'] = \"hint\", ['warn'] = \"warning\"}\nadmonitions: {['note'] = \"NOTICE\", ['tip'] = \"HINT\", ['warn'] = \"WARNING\"}"
  },
  {
    "objectID": "pages/table/map.html#see-also",
    "href": "pages/table/map.html#see-also",
    "title": "Lua Tables — Mapping & Transforming",
    "section": "See Also",
    "text": "See Also\nlulu.callable  Scribe"
  },
  {
    "objectID": "pages/table/find.html",
    "href": "pages/table/find.html",
    "title": "Lua Tables — Searches",
    "section": "",
    "text": "If you have imported the lulu.table module as\nrequire 'lulu.table'\nthen, you can search for particular keys and values in any table using the following methods.\ntable.find(tbl,value)  Returns the first key found in tbl where tbl[key] is identical in content to value.  This is a top-level search that returns nil on failure.\ntable.contains(tbl,value)  Returns true if there is a top-level value in tbl that is identical in content to value.\ntable.find_if(tbl,predicate,...)  Returns a key, value, p trio where p = predicate(value,...) is not nil and value = tbl[key].  This is a top-level search that returns nil on failure."
  },
  {
    "objectID": "pages/table/find.html#introduction",
    "href": "pages/table/find.html#introduction",
    "title": "Lua Tables — Searches",
    "section": "",
    "text": "If you have imported the lulu.table module as\nrequire 'lulu.table'\nthen, you can search for particular keys and values in any table using the following methods.\ntable.find(tbl,value)  Returns the first key found in tbl where tbl[key] is identical in content to value.  This is a top-level search that returns nil on failure.\ntable.contains(tbl,value)  Returns true if there is a top-level value in tbl that is identical in content to value.\ntable.find_if(tbl,predicate,...)  Returns a key, value, p trio where p = predicate(value,...) is not nil and value = tbl[key].  This is a top-level search that returns nil on failure."
  },
  {
    "objectID": "pages/table/find.html#table.find-table.contains",
    "href": "pages/table/find.html#table.find-table.contains",
    "title": "Lua Tables — Searches",
    "section": "table.find & table.contains",
    "text": "table.find & table.contains\nThe table.find method searches the top-level keys in tbl for the one whose corresponding value matches the searched-for item. The matches are done using table.eq so, if the hunted-for object is a table, we look for one identical in content, not just occupying the same memory blocks.\n\n    \n     \n    \n    \nThe search stops on the first match. The concept of “first” is nebulous for general Lua tables, as the elements are stored in an undefined order. The next time you run the search on a table with more than one match, you may get a different key. That will never happen for Lua arrays.\n\nThe table.contains(value) method is the same as table.find(tbl, value) ~= nil.\nExample\nrequire(\"lulu.table\")\nlocal p = {first = 'Joan', middle = 'Frances', last = 'Doe'}\nprint(\"Key for 'Doe':\", table.find(p,'Doe'))\nReturns the answer Key for 'Doe': last.\nIf we have a repeated value in a general table like:\nlocal p = {first = 'Joan', middle = 'Frances', last = 'Doe', other = 'Doe'}\nprint(\"Key for 'Doe':\", table.find(p,'Doe'))\nThen, if you run the code multiple times, you will get both Key for 'Doe': last and `Key for 'Doe': other.\nIf, instead, we have an array of values like:\nlocal p = {'Joan', 'Frances', 'Doe', 'Doe'}\nprint(\"Key for 'Doe':\", table.find(p,'Doe'))\nThen we always get Key for 'Doe': 3."
  },
  {
    "objectID": "pages/table/find.html#table.find_if",
    "href": "pages/table/find.html#table.find_if",
    "title": "Lua Tables — Searches",
    "section": "table.find_if",
    "text": "table.find_if\nThe table.find_if(tbl ,predicate,...) method allows for more complex searches.\nIt looks for a top-level key in tbl such that predicate(tbl[key], ...) ~= nil.  On success, it returns the trio key, tbl[key], predicate(tbl[key],...).  On failure, it returns the trio nil, nil, nil.\n\n    \n     \n    \n    \nThe search stops on the first non-nil return from the predicate function. As noted earlier, “first” is nebulous for general Lua tables, as the elements are stored in an undefined order.\n\nExample: General table\nHere, we search for the “first” value in a table that is larger than 42:\nlocal tbl = {foo = 41, boo = 42, bar = 43, baba = 44}\nprint(table.find_if(tbl, \"&gt;\", 42))\nIf you run this multiple times, you will get the trio: bar 43 true or baba 44 true. There is no fixed storage order for items in general Lua tables.\nWe also note that the returned third element will never be of interest in this example.\nExample: Lua array\nThe same example for a Lua array:\nlocal tbl = {41, 42, 43, 44}\nprint(table.find_if(tbl, \"&gt;\", 42))\nwill always output 3 43 true as the integer keys for Lua arrays are stored in a fixed order."
  },
  {
    "objectID": "pages/table/find.html#predicate-functions",
    "href": "pages/table/find.html#predicate-functions",
    "title": "Lua Tables — Searches",
    "section": "Predicate Functions",
    "text": "Predicate Functions\nThe predicate function can come in one of several forms:\n\nYou can use Lua function like table.find_if(tbl, function(v) return v &gt; 42 end).\nYou can use a string operator like we did above table.find_if(tbl, \"&gt;\", 42).\nYou can use a string lambda like table.find_if(tbl, \"|v| v &gt; 42\").\nYou can pass a “table” that is callable, i.e. it has a __call() metamethod.\n\nThere is more detail on the second and third options in the documentation for the lulu.callable module."
  },
  {
    "objectID": "pages/table/find.html#see-also",
    "href": "pages/table/find.html#see-also",
    "title": "Lua Tables — Searches",
    "section": "See Also",
    "text": "See Also\ntable.eq  table.keys  table.values  lulu.callable"
  },
  {
    "objectID": "pages/table/copy.html",
    "href": "pages/table/copy.html",
    "title": "Lua Tables — Deep & Shallow Copies",
    "section": "",
    "text": "Copying a Lua table using the assignment operator doesn’t copy anything! All you get is another pointer to the same block of memory.\nWe can illustrate that using the following example:\nlocal original = {a = 'alpha', b = 'beta'}\n1local copy = original\n2copy.a = 'GAMMA'\n3print(original.a)\n\n1\n\n“Copy” the original table using a simple assignment.\n\n2\n\nAlter the copy.\n\n3\n\nCheck the original and get the output, GAMMA!\n\n\nThis shows that original and copy are just two references to the same memory block."
  },
  {
    "objectID": "pages/table/copy.html#introduction",
    "href": "pages/table/copy.html#introduction",
    "title": "Lua Tables — Deep & Shallow Copies",
    "section": "",
    "text": "Copying a Lua table using the assignment operator doesn’t copy anything! All you get is another pointer to the same block of memory.\nWe can illustrate that using the following example:\nlocal original = {a = 'alpha', b = 'beta'}\n1local copy = original\n2copy.a = 'GAMMA'\n3print(original.a)\n\n1\n\n“Copy” the original table using a simple assignment.\n\n2\n\nAlter the copy.\n\n3\n\nCheck the original and get the output, GAMMA!\n\n\nThis shows that original and copy are just two references to the same memory block."
  },
  {
    "objectID": "pages/table/copy.html#table.clone-table.copy",
    "href": "pages/table/copy.html#table.clone-table.copy",
    "title": "Lua Tables — Deep & Shallow Copies",
    "section": "table.clone & table.copy",
    "text": "table.clone & table.copy\nIf you have imported the lulu.table module as\nrequire 'lulu.table'\nthen, you can make copies of any Lua table using the following two methods:\ntable.clone(tbl)  Returns a shallow copy of tbl. It does not copy any metatable.\ntable.copy(tbl)  Returns a deep copy of tbl, including metatables."
  },
  {
    "objectID": "pages/table/copy.html#shallow-vs.-deep",
    "href": "pages/table/copy.html#shallow-vs.-deep",
    "title": "Lua Tables — Deep & Shallow Copies",
    "section": "Shallow vs. Deep",
    "text": "Shallow vs. Deep\nThe clone and copy methods both start by creating a new empty table.\nA shallow clone then inserts copies of the top-level elements from tbl into that new table.\nOn the other hand, a deep copy copies all the elements from the tbl argument by recursively visiting all sub-tables, sub-sub-tables, and on.\n\n    \n     \n    \n    \nThe methods give identical results for arguments without sub-tables.\n\nExample: Simple Tables\n1local orig = {a = 'alpha', b = 'beta'}\n2local deep = table.copy(orig)\n3local shallow = table.clone(orig)\n\n4putln(\"original     = %t\", orig)\nputln(\"deep copy    = %t\", deep)\nputln(\"shallow copy = %t\", shallow)\n\n5deep.a = \"GAMMA\"\nputln(\"After setting `deep.a to '%s'`\", deep.a)\nputln(\"original     = %t\", orig)\nputln(\"deep copy    = %t\", deep)\nputln(\"shallow copy = %t\", shallow)\n\n6shallow.b= \"RHO\"\nputln(\"After setting `shallow. to '%s'`\", shallow.b)\nputln(\"original     = %t\", orig)\nputln(\"deep copy    = %t\", deep)\nputln(\"shallow copy = %t\", shallow)\n\n1\n\nHere, orig is a simple Lua table with two key, value pairs and no sub-tables.\n\n2\n\ndeep is a deep copy of orig, so we expect changes to deep not to change orig.\n\n3\n\nshallow is a shallow clone of orig, so changes to shallow might also affectorig`.\n\n4\n\nThe examples on this page use Scribe for formatted printing.\n\n5\n\nChange to deep will only be reflected in deep no matter the structure of orig.\n\n6\n\nBecause orig has no sub-tables, a change to shallow is only reflected in shallow.\n\n\nWhen you run the program, you get:\nOutput: Simple Tables\noriginal     = {['a'] = \"alpha\", ['b'] = \"beta\"}\ndeep copy    = {['a'] = \"alpha\", ['b'] = \"beta\"}\nshallow copy = {['a'] = \"alpha\", ['b'] = \"beta\"}\nAfter setting `deep.a to 'GAMMA'`\noriginal     = {['a'] = \"alpha\", ['b'] = \"beta\"}\n1deep copy    = {['a'] = \"GAMMA\", ['b'] = \"beta\"}\nshallow copy = {['a'] = \"alpha\", ['b'] = \"beta\"}\nAfter setting `shallow. to 'RHO'`\noriginal     = {['a'] = \"alpha\", ['b'] = \"beta\"}\ndeep copy    = {['a'] = \"GAMMA\", ['b'] = \"beta\"}\n2shallow copy = {['a'] = \"alpha\", ['b'] = \"RHO\"}\n\n1\n\nOnly deep is changed.\n\n2\n\nOnly shallow is changed.\n\n\nIn this example, the original table had no sub-tables, so there is no difference between deep copying and shallow cloning.\nThe results differ when we alter the example by putting the table values into sub-tables!\nExample: Table with Sub-Tables\n1local orig = {a = {'alpha'}, b = {'beta'}}\nlocal deep = table.copy(orig)\nlocal shallow = table.clone(orig)\n\nputln(\"original     = %t\", orig)\nputln(\"deep copy    = %t\", deep)\nputln(\"shallow copy = %t\", shallow)\n\ndeep.a[1] = \"GAMMA\"\n2putln(\"After setting `deep.a[1] to '%s'`\", deep.a[1])\nputln(\"original     = %t\", orig)\nputln(\"deep copy    = %t\", deep)\nputln(\"shallow copy = %t\", shallow)\n\nshallow.b[1]= \"RHO\"\n3putln(\"After setting `shallow.b[1] to '%s'`\", shallow.b[1])\nputln(\"original     = %t\", orig)\nputln(\"deep copy    = %t\", deep)\nputln(\"shallow copy = %t\", shallow)\n\n1\n\nHere, we have somewhat spuriously introduced sub-tables instead of setting orig.a = \"alpha\" we have orig.a[1] = \"alpha\"etc.\n\n2\n\nDeep copies are entirely independent, so this change will only affect deep.\n\n3\n\nShallow clones are only independent at the top level so this change will affect both shallow and orig. Of course, it will not affect the independent deep.\n\n\nNow, when you run the program, you get:\nOutput: Table with Sub-Tables\noriginal     = {['a'] = {\"alpha\"}, ['b'] = {\"beta\"}}\ndeep copy    = {['a'] = {\"alpha\"}, ['b'] = {\"beta\"}}\nshallow copy = {['a'] = {\"alpha\"}, ['b'] = {\"beta\"}}\nAfter setting `deep.a[1] to 'GAMMA'`\noriginal     = {['a'] = {\"alpha\"}, ['b'] = {\"beta\"}}\n1deep copy    = {['a'] = {\"GAMMA\"}, ['b'] = {\"beta\"}}\nshallow copy = {['a'] = {\"alpha\"}, ['b'] = {\"beta\"}}\nAfter setting `shallow.b[1] to 'RHO'`\noriginal     = {['a'] = {\"alpha\"}, ['b'] = {\"RHO\"}}\ndeep copy    = {['a'] = {\"GAMMA\"}, ['b'] = {\"beta\"}}\n2shallow copy = {['a'] = {\"alpha\"}, ['b'] = {\"RHO\"}}\n\n1\n\nAs expected, a change to a sub-element is only seen deep.\n\n2\n\nIn contrast, a change to a sub-element is seen in the shallow copy and also in the original table.\n\n\n\n    \n     \n    \n    \nThe only native complex type in Lua is a table, so every non-trivial data structure will have tables with sub-tables. For this reason, it is essential to understand the distinction between having multiple references by assignment, shallow cloning, and deep copying."
  },
  {
    "objectID": "pages/table/copy.html#see-also",
    "href": "pages/table/copy.html#see-also",
    "title": "Lua Tables — Deep & Shallow Copies",
    "section": "See Also",
    "text": "See Also\ntable.eq"
  },
  {
    "objectID": "pages/lpeg/index.html",
    "href": "pages/lpeg/index.html",
    "title": "Lua LPEG — Extensions",
    "section": "",
    "text": "The lulu.xpeg module extends the standardlpeg module with predefined patterns and useful functions.",
    "crumbs": [
      "Home",
      "Extensions: LPEG"
    ]
  },
  {
    "objectID": "pages/lpeg/index.html#introduction",
    "href": "pages/lpeg/index.html#introduction",
    "title": "Lua LPEG — Extensions",
    "section": "",
    "text": "The lulu.xpeg module extends the standardlpeg module with predefined patterns and useful functions.",
    "crumbs": [
      "Home",
      "Extensions: LPEG"
    ]
  },
  {
    "objectID": "pages/lpeg/index.html#patterns",
    "href": "pages/lpeg/index.html#patterns",
    "title": "Lua LPEG — Extensions",
    "section": "Patterns",
    "text": "Patterns\nIf you have imported the module as\nlocal lpeg = require 'lulu.xpeg'\nYou then have access to many “standard” LPEG patterns in the lpeg.patterns table.\nFor convenience define:\nlocal p = lpeg.patterns\nThen:\n\n\n\n\n\n\n\n\nPattern\nDescription\n\n\n\n\np.any\nMatches any character.\n\n\np.eos\nMatches the end of the subject or string.\n\n\np.esc\nMatches the standard escape character — the backslash.\n\n\np.alpha\nMatches alphabetic characters.\n\n\np.digit\nMatches decimal digits.\n\n\np.alphanumeric\nMatches alphanumeric characters.\n\n\np.lower\nMatches lowercase letters.\n\n\np.upper\nMatches uppercase letters.\n\n\np.graph\nMatches printable characters.\n\n\np.punctuation\nMatches non-alphanumeric printable chars.\n\n\np.hs\nMatches horizontal space.\n\n\np.ws\nMatches whitespace including newlines.\n\n\np.non_hs\nMatches non-horizontal space characters.\n\n\np.non_ws\nMatches non-whitespace characters.\n\n\np.nl\nMatches newlines (DOS and Unix).\n\n\np.non_nl\nMatches non-newline characters (DOS & Unix).\n\n\np.eol\nMatches end-of-line or end-of-subject.\n\n\np.non_eol\nMatches non-end-of-line characters.\n\n\np.sign\nMatches plus or minus signs.\n\n\np.bin_digit\nMatches binary digits without digit separators.\n\n\np.oct_digit\nMatches octal digits without digit separators.\n\n\np.dec_digit\nMatches decimal digits without digit separators.\n\n\np.hex_digit\nMatches hexadecimal digits without digit separators.\n\n\np.dec\nMatches any decimal number without digit separators.\n\n\np.hex\nMatches any hexadecimal number without digit separators.\n\n\np.oct\nMatches an octal number without digit separators.\n\n\np.bin\nMatches any binary number without digit separators.\n\n\np.int\nMatches any integer without digit separators.\n\n\np.float\nMatches any floating point number without digit separators.\n\n\np.num\nMatches any number without digit separators.\n\n\np.ws_trim\nCapture pattern that ignores leading and trailing whitespace.\n\n\np.ws_collapse\nSubstitution capture that trims and collapses all contiguous interior white-spaces to a single space.\n\n\np.ws_delete\nSubstitution capture that removes all whitespace.\n\n\np.blocks\nTable capture all the text blocks/paragraphs in a subject string.  A block/paragraph is text followed by one or more empty lines or the end of the string.\n\n\np.single_quoted\nMatches single quoted strings.\n\n\np.double_quoted\nMatches double quoted strings.\n\n\np.quoted\nMatches either single or double quoted strings.\n\n\np.single_quoted_content\nCapture content inside single quotes.\n\n\np.double_quoted_content\nCapture content inside double quotes.\n\n\np.quoted_content\nCapture content inside single or double quotes.\n\n\np.careful_collapse_ws\nSubstitution capture that trims and collapses contiguous interior white-spaces to one space but not inside quotes.",
    "crumbs": [
      "Home",
      "Extensions: LPEG"
    ]
  },
  {
    "objectID": "pages/lpeg/index.html#methods",
    "href": "pages/lpeg/index.html#methods",
    "title": "Lua LPEG — Extensions",
    "section": "Methods",
    "text": "Methods\nIf you have imported the module as\nlocal lpeg = require 'lulu.lpeg'\nYou also have access to the following methods:\n\n\n\n\n\n\n\n\nPattern\nDescription\n\n\n\n\nlpeg.dec_number(sep)\nMatch unsigned decimal integers with optional digit group separators.\n\n\nlpeg.hex_number(sep)\nMatch unsigned hexadecimal integers with optional digit group separators.\n\n\nlpeg.oct_number(sep)\nMatch unsigned octal integers with optional digit group separators.\n\n\nlpeg.bin_number(sep)\nMatch unsigned binary integers with optional digit group separators.\n\n\nlpeg.int_number(sep)\nMatch any form of signed integer with optional digit group separators.\n\n\nlpeg.float_number(sep)\nMatch any form of signed float with optional digit group separators.\n\n\nlpeg.number(sep)\nMatch any form of signed number with optional digit group separators.\n\n\nlpeg.is_pattern(ptn)\nQuery to see if an argument is an lpeg pattern.\n\n\nlpeg.anywhere(ptn)\nCreates a pattern that allows ptn to work anywhere in a subject string.\n\n\nlpeg.change(ptn,to)\nCreates a substitution pattern that acts on strings so matches to ptn are changed to to.\n\n\nlpeg.is_escaped(esc)\nCreates a pattern that checks whether a string starts with an escape character.  The default escape character is the backslash.\n\n\nlpeg.unescape(chars, esc)\nCreates a pattern that turns escaped characters into unescaped ones.  The default chars is \", the default esc is the backslash.\n\n\nlpeg.to_eol(from)\nCreates a pattern that matches starting with string/pattern from until the end of the line.\n\n\nlpeg.tokenizer(sep)\nCreates a table capture pattern to split a string into tokens based on a separator/pattern.\n\n\nlpeg.before(sep)\nCreates a capture pattern for all content before the first occurrence of a separator/pattern.\n\n\nlpeg.after(sep)\nCreates a capture pattern for all content after the first occurrence of a separator/pattern.\n\n\nlpeg.delimited(l,r,line)\nCreates a pattern to match delimited content.\n\n\nlpeg.delimited_content(l,r,line)\nCreates a pattern to capture delimited content.\n\n\nlpeg.after_set(set,ptn,skip)\nCreates a new pattern where ptn is only matched if it is preceded by a character in the set string. The skip string is used to skip over characters between the set and the ptn match (default whitespace).\n\n\nlpeg.after_newline(ptn, allow_indent)\nCreates a new pattern where ptn is only matched if it is preceded by a newline character.\n\n\n\n\n\nNotes\nAn example of the sep character for the various lpeg.*_number(sep) might be a comma.\nIn the lpeg.delimited*(l, r, line) methods, l is the left delimiter, r is the right delimiter.  If the final boolean line is true (default is false) then the match stops at the first newline.\n\nIf neither delimiter is given then we default to using double quotes: “…”.\nIf only one delimiter is given and it’s a single character (e.g. “‘“) then we use that for both:’…’.\nIf only one delimiter is given with an even number of characters (e.g. “{}”) then we split it in half ‘{’ and ‘}’.\nYou can of course specify the left and right delimiters separately.\nIf l == r then escaped delimiters aren’t matched: “inner \"quote\" here” matches the whole string.\nIf l != r then we ‘balance’ so “{}” applied to “{123{45}67}” matches on ‘123{45}67’.",
    "crumbs": [
      "Home",
      "Extensions: LPEG"
    ]
  },
  {
    "objectID": "pages/lpeg/index.html#see-also",
    "href": "pages/lpeg/index.html#see-also",
    "title": "Lua LPEG — Extensions",
    "section": "See Also",
    "text": "See Also\nThese patterns and methods can be used on a stand-alone basis. In many cases, they act as the engine driving methods in the lulu.string module which extends Lua’s string class.\nlulu.string",
    "crumbs": [
      "Home",
      "Extensions: LPEG"
    ]
  },
  {
    "objectID": "pages/Enum/index.html",
    "href": "pages/Enum/index.html",
    "title": "Lulu — Enums",
    "section": "",
    "text": "Enums are a way of specifying that a variable can only take on one of a limited number of choices.\nFor example, in C++ you might define the Suit for a card game as:\nenum class Suit = { Clubs, Diamonds, Hearts, Spades };\nThis declaration defines Suit as an enumerated type, an enumeration or enum for short, whose instances can only be one of the four allowed choices.\nThe named choices in an enumeration are often called the enumerators.\nIn effect, an enumeration introduces some named constants that are available for variable assignment. Of course, we need to be able to compare enumerators. Other than that, the memory layout and implementation can be opaque.\nEarly programming languages did not have enumerated types as part of the language. You would instead define some integer constants for the Suit choices (probably in a Suit.h header file):\n#define CLUBS       0\n#define DIAMONDS    1\n#define HEARTS      2\n#define SPADES      3\nThen later, have code that includes that header and has statements like if(suit == DIAMONDS) { ... }.\nHowever, using magic numbers like this makes source code hard to read and prone to errors.\nIt is evident that, even for our simple example, using the enum Suit type makes the code much more self-documenting. For this reason, most modern programming languages support some form of enumerated type as a core concept in the language itself.\nMoreover, languages usually have specific constructs designed to work naturally with their idea of what an enumerated type should be — the switch statement in C and C++, or various match statements in other languages. Those constructs may be more generally applicable, but their core design has the language’s enumerated type as their core raison d’etre.\nProgramming languages have implemented the idea of an enum in various ways.\nThey can be very simple, like in C and C++ where every enumerator is an integer of some sort. Other languages like Rust and Swift allow enumerators to own arbitrary associated data and methods. There will still be an underlying ordinal somewhere (perhaps a compiler construct) that defines an ordering of the enumerators.\nLua does not have a native enumerated type or anything like a multi-armed switch or match block.\nIt only has one complex native type, the all-powerful table. So you might have code like:\nSuit = { Clubs = 1, Diamonds = 2, Hearts = 3, Spades = 4 }\nlocal function is_black(s)\n    return s == Suit.Clubs or s == Suit.Spades\nend\n\nlocal s = Suit.Diamonds\nprint(\"Suit\", s, \" is black:\", is_black(s))\nThis outputs Suit 2 is black: false.\nThis works but isn’t suitable for anything except the trivial scripts. For one thing, the Suit table is not constant and can easily be changed by mistake.",
    "crumbs": [
      "Home",
      "The Enum Class"
    ]
  },
  {
    "objectID": "pages/Enum/index.html#introduction",
    "href": "pages/Enum/index.html#introduction",
    "title": "Lulu — Enums",
    "section": "",
    "text": "Enums are a way of specifying that a variable can only take on one of a limited number of choices.\nFor example, in C++ you might define the Suit for a card game as:\nenum class Suit = { Clubs, Diamonds, Hearts, Spades };\nThis declaration defines Suit as an enumerated type, an enumeration or enum for short, whose instances can only be one of the four allowed choices.\nThe named choices in an enumeration are often called the enumerators.\nIn effect, an enumeration introduces some named constants that are available for variable assignment. Of course, we need to be able to compare enumerators. Other than that, the memory layout and implementation can be opaque.\nEarly programming languages did not have enumerated types as part of the language. You would instead define some integer constants for the Suit choices (probably in a Suit.h header file):\n#define CLUBS       0\n#define DIAMONDS    1\n#define HEARTS      2\n#define SPADES      3\nThen later, have code that includes that header and has statements like if(suit == DIAMONDS) { ... }.\nHowever, using magic numbers like this makes source code hard to read and prone to errors.\nIt is evident that, even for our simple example, using the enum Suit type makes the code much more self-documenting. For this reason, most modern programming languages support some form of enumerated type as a core concept in the language itself.\nMoreover, languages usually have specific constructs designed to work naturally with their idea of what an enumerated type should be — the switch statement in C and C++, or various match statements in other languages. Those constructs may be more generally applicable, but their core design has the language’s enumerated type as their core raison d’etre.\nProgramming languages have implemented the idea of an enum in various ways.\nThey can be very simple, like in C and C++ where every enumerator is an integer of some sort. Other languages like Rust and Swift allow enumerators to own arbitrary associated data and methods. There will still be an underlying ordinal somewhere (perhaps a compiler construct) that defines an ordering of the enumerators.\nLua does not have a native enumerated type or anything like a multi-armed switch or match block.\nIt only has one complex native type, the all-powerful table. So you might have code like:\nSuit = { Clubs = 1, Diamonds = 2, Hearts = 3, Spades = 4 }\nlocal function is_black(s)\n    return s == Suit.Clubs or s == Suit.Spades\nend\n\nlocal s = Suit.Diamonds\nprint(\"Suit\", s, \" is black:\", is_black(s))\nThis outputs Suit 2 is black: false.\nThis works but isn’t suitable for anything except the trivial scripts. For one thing, the Suit table is not constant and can easily be changed by mistake.",
    "crumbs": [
      "Home",
      "The Enum Class"
    ]
  },
  {
    "objectID": "pages/Enum/index.html#the-enum-class",
    "href": "pages/Enum/index.html#the-enum-class",
    "title": "Lulu — Enums",
    "section": "The Enum Class",
    "text": "The Enum Class\nThe lulu.Enum module provides a specific class for this common data structure.\nOur enums have constant enumerators that cannot easily be changed.\nIf you have imported the lulu.Enum module as:\nlocal Enum = require 'lulu.Enum'\nthen, you have access to the following methods:\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nEnum:new\nCreate an Enum instance in various ways.\n\n\nENUM\nAn alternative syntax for creating Enum instances with a preset type.\n\n\nEnum:set_type\nSet the type of an Enum to a string. The default type is Enum.\n\n\nEnum:type\nGet the type of an Enum. The default type is Enum.\n\n\nEnum:is_instance\nCheck if an object is an instance of Enum.\n\n\nEnum:count\nGet the number of enumerators in an Enum.\n\n\nEnum:iter\nReturns an iterator that traverses the enumerators of an Enum in sorted order.\n\n\nEnum:mt\nReturns the metatable shared by all the enumerators of an Enum.\n\n\nEnum:inline\nReturns a one-line string representation of an Enum.\n\n\nEnum:pretty\nReturns a pretty-printed string representation of an Enum.\n\n\nEnum:__tostring\nA metamethod that connects Lua’s tostring and print functions to the Enum:inline method.\n\n\nEnum:add_enumerator\nAdd an enumerator to an Enum.",
    "crumbs": [
      "Home",
      "The Enum Class"
    ]
  },
  {
    "objectID": "pages/Enum/index.html#the-enumerator-class",
    "href": "pages/Enum/index.html#the-enumerator-class",
    "title": "Lulu — Enums",
    "section": "The Enumerator Class",
    "text": "The Enumerator Class\nThe Enumerator class is used to represent the enumerators of an Enum and has the following methods:\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nEnumerator:tostring\nReturns the name of the enumerator.  Enumerator names are unique within an Enum.\n\n\nEnumerator:tonumber\nReturns the ordinal value of the enumerator.  By default, ordinals are consecutive integers starting at 1.  However, they can be set to other values and need not be unique.\n\n\nEnumerator:is_a\nReturns true if the argument is an Enumerator that belongs to the argument Enum.\n\n\nEnumerator:__eq\nCompares enumerators by their ordinal values.\n\n\nEnumerator:__lt\nCompares enumerators by their ordinal values.\n\n\nEnumerator:__le\nCompares enumerators by their ordinal values.\n\n\nEnumerator:__index\nThis metamethod allows direct access to any associated data for the enumerator.\n\n\nEnumerator:__newindex\nThis metamethod prevents attempts to set values in an enumerator.\n\n\nEnumerator:__tostring\nA metamethod that connects Lua’s tostring and print functions to the Enumerator:tostring method.\n\n\n\n\n\n    \n     \n    \n    \nEnumerator instances are immutable and generated by the Enum class.  They are not usually created directly.\n\nYou access enumerators through an Enum instance.\nFor example:\nlocal Suit = Enum{ 'Clubs', 'Diamonds', 'Hearts', 'Spades' }\nlocal s = Suit.Clubs\nputln(\"Suit %s has ordinal %d\", s, s:tonumber())\nThis outputs Suit Clubs has ordinal 1.",
    "crumbs": [
      "Home",
      "The Enum Class"
    ]
  },
  {
    "objectID": "pages/Enum/index.html#see-also",
    "href": "pages/Enum/index.html#see-also",
    "title": "Lulu — Enums",
    "section": "See Also",
    "text": "See Also\nlulu.Array",
    "crumbs": [
      "Home",
      "The Enum Class"
    ]
  },
  {
    "objectID": "pages/Enum/to_string.html",
    "href": "pages/Enum/to_string.html",
    "title": "Lulu Enums — Stringification",
    "section": "",
    "text": "We provide a number of methods for converting Enum instances to strings.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nEnum:inline()\nReturns a one-line string representation of self.\n\n\nEnum:pretty()\nReturns a “pretty” multiline string representation of self.\n\n\nEnum:tostring(indent)\nReturns a string representation of self with custom indentation.\n\n\nEnum:__tostring()\nA metamethod that connects Lua’s tostring and print functions to the Enum:inline method.\n\n\n\n\nThe methods all show the enumerator names preceded by their ordinal values in square brackets. Associated data for the enumerators is also shown if present.\nThese methods play nicely with the scribe.putln formatted output functions in the Scribe module."
  },
  {
    "objectID": "pages/Enum/to_string.html#introduction",
    "href": "pages/Enum/to_string.html#introduction",
    "title": "Lulu Enums — Stringification",
    "section": "",
    "text": "We provide a number of methods for converting Enum instances to strings.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nEnum:inline()\nReturns a one-line string representation of self.\n\n\nEnum:pretty()\nReturns a “pretty” multiline string representation of self.\n\n\nEnum:tostring(indent)\nReturns a string representation of self with custom indentation.\n\n\nEnum:__tostring()\nA metamethod that connects Lua’s tostring and print functions to the Enum:inline method.\n\n\n\n\nThe methods all show the enumerator names preceded by their ordinal values in square brackets. Associated data for the enumerators is also shown if present.\nThese methods play nicely with the scribe.putln formatted output functions in the Scribe module."
  },
  {
    "objectID": "pages/Enum/to_string.html#enuminline",
    "href": "pages/Enum/to_string.html#enuminline",
    "title": "Lulu Enums — Stringification",
    "section": "Enum:inline",
    "text": "Enum:inline\nThis is the default method used by Lua’s print and friends. It is also used by the putln function when the format specifier is %t.\nExample\nlocal Suit = Enum{ 'Clubs', 'Diamonds', 'Hearts', 'Spades' }\nprint(Suit)\nOutput\nEnum: [1] Clubs, [2] Diamonds, [3] Hearts, [4] Spades"
  },
  {
    "objectID": "pages/Enum/to_string.html#enumpretty",
    "href": "pages/Enum/to_string.html#enumpretty",
    "title": "Lulu Enums — Stringification",
    "section": "Enum:pretty",
    "text": "Enum:pretty\nThis is a “pretty” multiline string representation of self. It is used by the putln function when the format specifier is %T.\nExample\nlocal Suit = Enum({\n    Clubs    = { abbrev = 'C', color = 'black', icon = '♣', ordinal = 0 },\n    Diamonds = { abbrev = 'D', color = 'red',   icon = '♦', ordinal = 1 },\n    Hearts   = { abbrev = 'H', color = 'red',   icon = '♥', ordinal = 2 },\n    Spades   = { abbrev = 'S', color = 'black', icon = '♠', ordinal = 3 }\n})\n1putln(\"%T\", Suit)\n\n1\n\nThe %T format specifier tells putln to use the Enum:pretty method to convert the Enum instance to a string.\n\n\nOutput\nEnum:\n    [0] Clubs = { abbrev = \"C\", color = \"black\", icon = \"♣\" },\n    [1] Diamonds = { abbrev = \"D\", color = \"red\", icon = \"♦\" },\n    [2] Hearts = { abbrev = \"H\", color = \"red\", icon = \"♥\" },\n    [3] Spades = { abbrev = \"S\", color = \"black\", icon = \"♠\" }"
  },
  {
    "objectID": "pages/Enum/to_string.html#enumtostringindent",
    "href": "pages/Enum/to_string.html#enumtostringindent",
    "title": "Lulu Enums — Stringification",
    "section": "Enum:tostring(indent)",
    "text": "Enum:tostring(indent)\nThis is a string representation of self with custom indentation. It is the workhorse method used by Enum:inline and Enum:pretty.\nExample\nprint(Suit:tostring(' '))\nOutput\nEnum:\n  [0] Clubs = { abbrev = \"C\", color = \"black\", icon = \"♣\" },\n  [1] Diamonds = { abbrev = \"D\", color = \"red\", icon = \"♦\" },\n  [2] Hearts = { abbrev = \"H\", color = \"red\", icon = \"♥\" },\n  [3] Spades = { abbrev = \"S\", color = \"black\", icon = \"♠\" }"
  },
  {
    "objectID": "pages/Enum/to_string.html#see-also",
    "href": "pages/Enum/to_string.html#see-also",
    "title": "Lulu Enums — Stringification",
    "section": "See Also",
    "text": "See Also\nEnum:mt"
  },
  {
    "objectID": "pages/Enum/type.html",
    "href": "pages/Enum/type.html",
    "title": "Lulu Enums — Enum Type Names",
    "section": "",
    "text": "The Enum class has a __name field that returns the type of the Enum instance.\n\n    \n     \n    \n    \nThe default type is Enum.\n\nYou can set the type of an Enum instance using the Enum:set_type method and retrieve it using the Enum:type method.\nlocal Suit = Enum{ 'Clubs', 'Diamonds', 'Hearts', 'Spades' }\nSuit:set_type('Suit')\nputln(\"The enum's type is %s\", Suit:type())\nThis outputs The enum's type is Suit.\nThe type is used in the string representation of the Enum instance, so print(Suit) outputs:\nSuit: [1] Clubs, [2] Diamonds, [3] Hearts, [4] Spades"
  },
  {
    "objectID": "pages/Enum/type.html#type-names",
    "href": "pages/Enum/type.html#type-names",
    "title": "Lulu Enums — Enum Type Names",
    "section": "",
    "text": "The Enum class has a __name field that returns the type of the Enum instance.\n\n    \n     \n    \n    \nThe default type is Enum.\n\nYou can set the type of an Enum instance using the Enum:set_type method and retrieve it using the Enum:type method.\nlocal Suit = Enum{ 'Clubs', 'Diamonds', 'Hearts', 'Spades' }\nSuit:set_type('Suit')\nputln(\"The enum's type is %s\", Suit:type())\nThis outputs The enum's type is Suit.\nThe type is used in the string representation of the Enum instance, so print(Suit) outputs:\nSuit: [1] Clubs, [2] Diamonds, [3] Hearts, [4] Spades"
  },
  {
    "objectID": "pages/Enum/type.html#the-enum-function",
    "href": "pages/Enum/type.html#the-enum-function",
    "title": "Lulu Enums — Enum Type Names",
    "section": "The ENUM Function",
    "text": "The ENUM Function\nThe lulu.Enum module exports the ENUM function which gives you an alternative way to create an Enum instance with a preset type.\nENUM 'Suit' { 'Clubs', 'Diamonds', 'Hearts', 'Spades' }\nThe first string after the ENUM keyword is the type of the Enum instance. The rest of the arguments are the same as those for the Enum:new method."
  },
  {
    "objectID": "pages/Enum/type.html#enumis_instance",
    "href": "pages/Enum/type.html#enumis_instance",
    "title": "Lulu Enums — Enum Type Names",
    "section": "Enum:is_instance",
    "text": "Enum:is_instance\nThe Enum:is_instance is a “static” method that returns true if the argument is an Enum instance.\nlocal Suit = Enum{ 'Clubs', 'Diamonds', 'Hearts', 'Spades' }\n1putln(\"Suit is an enum:       %s\", Enum.is_instance(Suit))\nputln(\"Suit.Clubs is an enum: %s\", Enum.is_instance(Suit.Clubs))\n\n1\n\nis_instance is a static class method so you call it as Enum.is_instance(obj) as opposed to Enum:is_instance(Suit).\n\n\nThis outputs:\nSuit is an enum:       true\nSuit.Clubs is an enum: false"
  },
  {
    "objectID": "pages/Enum/type.html#see-also",
    "href": "pages/Enum/type.html#see-also",
    "title": "Lulu Enums — Enum Type Names",
    "section": "See Also",
    "text": "See Also\nEnum:tostring  Enum:new  ENUM"
  },
  {
    "objectID": "pages/types/index.html",
    "href": "pages/types/index.html",
    "title": "Type Checking Utilities",
    "section": "",
    "text": "The lulu.types module has a few functions for checking the type of a value.",
    "crumbs": [
      "Home",
      "Type Utilities"
    ]
  },
  {
    "objectID": "pages/types/index.html#introduction",
    "href": "pages/types/index.html#introduction",
    "title": "Type Checking Utilities",
    "section": "",
    "text": "The lulu.types module has a few functions for checking the type of a value.",
    "crumbs": [
      "Home",
      "Type Utilities"
    ]
  },
  {
    "objectID": "pages/types/index.html#methods",
    "href": "pages/types/index.html#methods",
    "title": "Type Checking Utilities",
    "section": "Methods",
    "text": "Methods\nIf you have imported the module as\nlocal types = require 'lulu.types'\nthen you have access to the following methods:\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\ntypes.is_integer(val)\nReturns true if val is an integer.\n\n\ntypes.is_positive_integer(val)\nReturns true if val is a positive integer.\n\n\ntypes.is_negative_integer(val)\nReturns true if val is a negative integer.\n\n\ntypes.is_nan(val)\nReturns true if val a NaN.\n\n\n\n\nThese functions are mostly self-explanatory, and mostly are simple one-liners.",
    "crumbs": [
      "Home",
      "Type Utilities"
    ]
  },
  {
    "objectID": "pages/types/index.html#types.type",
    "href": "pages/types/index.html#types.type",
    "title": "Type Checking Utilities",
    "section": "types.type",
    "text": "types.type\nFor tables with a string field __name this returns that string. Otherwise it returns the output from the Lua standard type function.\n\n    \n     \n    \n    \nThe shorthand types(obj) is a synonym for types.type(obj).",
    "crumbs": [
      "Home",
      "Type Utilities"
    ]
  },
  {
    "objectID": "pages/types/index.html#see-also",
    "href": "pages/types/index.html#see-also",
    "title": "Type Checking Utilities",
    "section": "See Also",
    "text": "See Also\nlulu.table  lulu.Array",
    "crumbs": [
      "Home",
      "Type Utilities"
    ]
  },
  {
    "objectID": "pages/Array/is_array_of.html",
    "href": "pages/Array/is_array_of.html",
    "title": "Lulu Arrays — Element Type Checks",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen you have access to the following methods to check consistency for the array elements’ type.\nArray:is_array_of(e_type)  Returns true if all the elements in the array have the given type e_type.  Element types are determined by the lulu.types method which is slightly more discriminating that the standard Lua type function.\nArray:is_array_of_one_type()  Returns true if all the elements in the array have the same type.  Element types are determined by the lulu.types method which is slightly more discriminating that the standard Lua type function.\nArray:is_array_of_numbers()  Returns true if all the elements in the array are numbers,\nArray:is_array_of_strings()  Returns true if all the elements in the array are strings,"
  },
  {
    "objectID": "pages/Array/is_array_of.html#introduction",
    "href": "pages/Array/is_array_of.html#introduction",
    "title": "Lulu Arrays — Element Type Checks",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen you have access to the following methods to check consistency for the array elements’ type.\nArray:is_array_of(e_type)  Returns true if all the elements in the array have the given type e_type.  Element types are determined by the lulu.types method which is slightly more discriminating that the standard Lua type function.\nArray:is_array_of_one_type()  Returns true if all the elements in the array have the same type.  Element types are determined by the lulu.types method which is slightly more discriminating that the standard Lua type function.\nArray:is_array_of_numbers()  Returns true if all the elements in the array are numbers,\nArray:is_array_of_strings()  Returns true if all the elements in the array are strings,"
  },
  {
    "objectID": "pages/Array/is_array_of.html#see-also",
    "href": "pages/Array/is_array_of.html#see-also",
    "title": "Lulu Arrays — Element Type Checks",
    "section": "See Also",
    "text": "See Also\nArray:size  Array:is_empty  lulu.types"
  },
  {
    "objectID": "pages/Array/change.html",
    "href": "pages/Array/change.html",
    "title": "Lulu Arrays — Changing Elements etc.",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you can use the following methods:\nArray:clear(start)  Clears self from self[start] on.  The default value for start is 1, which clears the entire array. Negative start counts back from the end of the array.\nArray:push(value)  Add a value to the end of the array amd return self to allow for chaining.  This is just a synonym for table.insert(self, value).\nArray:pop()  Remove the value from the end of self and return the value removed.  This is just a synonym for table.remove(self).\nArray:insert(pos, value)  Insert a value at position pos and return self to allow for chaining.  This is just a synonym for table.insert(self, pos, value) so if pos is in the interior of self then existing elements are shifted to the next-greater index.\nArray:remove(pos)  Remove the value at position pos and return the value removed.  This is just a synonym for table.remove(self, pos) so if pos is in the interior of self then existing elements are shifted down as needed.\nArray:append(...)  Appends the passed arguments to the end of the array & return self to allow for chaining.  If any passed argument is itself an Array we append the values from that argument (unwrapping by one level).\nArray:sort(comparator)  Sorts self in-place; the comparator argument is optional.  The default comparator sorts the elements by type first and then alphabetically.\nArray:shuffle()  Shuffles the elements ofself in place.\nArray:reverse()  Reverses the elements of self in place.\nArray:reversed()  Returns a new Array that in a copy of self with the elements in reverse order.  The other methods on this page all change self — this is the exception.\nArray:delete(m, n)\nEfficiently deletes the elements from index m to index n inclusive. Negative m and n count back from the end of the array. If there is no n argument, we delete the first or final m elements. The no-argument call arr:delete() deletes the first element in arr.\nArray:keep(m, n)\nEfficiently deletes the elements except from index m to index n inclusive. Negative m and n count back from the end of the array. If there is no n argument, we delete the first or final m elements. The no-argument call arr:keep() deletes the final element in arr.\nArray:delete_if(prd, ...)\nThis call deletes any element in the array that passes a predicate test. The test is called as prd(arr[i], ...) for each element arr[i] in the array.\nThe predicate can be anything lulu.callable can interpret as a function.\nArray:keep_if(prd, ...)\nThis call deletes any element in the array that does not passes a predicate test. The test is called as prd(arr[i], ...) for each element arr[i] in the array.\nThe predicate can be anything lulu.callable can interpret as a function."
  },
  {
    "objectID": "pages/Array/change.html#introduction",
    "href": "pages/Array/change.html#introduction",
    "title": "Lulu Arrays — Changing Elements etc.",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you can use the following methods:\nArray:clear(start)  Clears self from self[start] on.  The default value for start is 1, which clears the entire array. Negative start counts back from the end of the array.\nArray:push(value)  Add a value to the end of the array amd return self to allow for chaining.  This is just a synonym for table.insert(self, value).\nArray:pop()  Remove the value from the end of self and return the value removed.  This is just a synonym for table.remove(self).\nArray:insert(pos, value)  Insert a value at position pos and return self to allow for chaining.  This is just a synonym for table.insert(self, pos, value) so if pos is in the interior of self then existing elements are shifted to the next-greater index.\nArray:remove(pos)  Remove the value at position pos and return the value removed.  This is just a synonym for table.remove(self, pos) so if pos is in the interior of self then existing elements are shifted down as needed.\nArray:append(...)  Appends the passed arguments to the end of the array & return self to allow for chaining.  If any passed argument is itself an Array we append the values from that argument (unwrapping by one level).\nArray:sort(comparator)  Sorts self in-place; the comparator argument is optional.  The default comparator sorts the elements by type first and then alphabetically.\nArray:shuffle()  Shuffles the elements ofself in place.\nArray:reverse()  Reverses the elements of self in place.\nArray:reversed()  Returns a new Array that in a copy of self with the elements in reverse order.  The other methods on this page all change self — this is the exception.\nArray:delete(m, n)\nEfficiently deletes the elements from index m to index n inclusive. Negative m and n count back from the end of the array. If there is no n argument, we delete the first or final m elements. The no-argument call arr:delete() deletes the first element in arr.\nArray:keep(m, n)\nEfficiently deletes the elements except from index m to index n inclusive. Negative m and n count back from the end of the array. If there is no n argument, we delete the first or final m elements. The no-argument call arr:keep() deletes the final element in arr.\nArray:delete_if(prd, ...)\nThis call deletes any element in the array that passes a predicate test. The test is called as prd(arr[i], ...) for each element arr[i] in the array.\nThe predicate can be anything lulu.callable can interpret as a function.\nArray:keep_if(prd, ...)\nThis call deletes any element in the array that does not passes a predicate test. The test is called as prd(arr[i], ...) for each element arr[i] in the array.\nThe predicate can be anything lulu.callable can interpret as a function."
  },
  {
    "objectID": "pages/Array/change.html#arrayclear",
    "href": "pages/Array/change.html#arrayclear",
    "title": "Lulu Arrays — Changing Elements etc.",
    "section": "Array:clear()",
    "text": "Array:clear()\nClears n array in-place from an optional start index. If the start index is not given, the entire array is cleared. If the start index is negative, it counts back from the end of the array.\nExample:\nlocal n = 10\nlocal arr = Array:range(1,n,1)\nfor i = 0, n do\n1    putln(\"Array: %t\", arr)\n2    arr:clear(10-i)\nend\n\n1\n\nThe examples on this page use lulu.scribe for formatted printing.\n\n2\n\nThe start index is negative, so it counts back from the end of the array.\n\n\nOutput:\nArray: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]\nArray: [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\nArray: [ 1, 2, 3, 4, 5, 6, 7, 8 ]\nArray: [ 1, 2, 3, 4, 5, 6, 7 ]\nArray: [ 1, 2, 3, 4, 5, 6 ]\nArray: [ 1, 2, 3, 4, 5 ]\nArray: [ 1, 2, 3, 4 ]\nArray: [ 1, 2, 3 ]\nArray: [ 1, 2 ]\nArray: [ 1 ]\nArray: []\n\n    \n     \n    \n    \nThis method can be helpful for temporary arrays holding large table elements. The clear method sets those elements to nil, which is a hint to Lua’s garbage collector to free up memory."
  },
  {
    "objectID": "pages/Array/change.html#arrayinsert",
    "href": "pages/Array/change.html#arrayinsert",
    "title": "Lulu Arrays — Changing Elements etc.",
    "section": "Array:insert",
    "text": "Array:insert\nExample\nlocal arr = Array:range(1,9)\nputln(\"Original: %t\", arr)\nfor i = 1,9 do\n    putln(\"Inserted %d at position %d: %t\", i, i, arr:insert(i,i))\nend\nOutput\nOriginal: [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\nInserted 1 at position 1: [ 1, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\nInserted 2 at position 2: [ 1, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\nInserted 3 at position 3: [ 1, 2, 3, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\nInserted 4 at position 4: [ 1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\nInserted 5 at position 5: [ 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\nInserted 6 at position 6: [ 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\nInserted 7 at position 7: [ 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\nInserted 8 at position 8: [ 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\nInserted 9 at position 9: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]"
  },
  {
    "objectID": "pages/Array/change.html#arrayappend",
    "href": "pages/Array/change.html#arrayappend",
    "title": "Lulu Arrays — Changing Elements etc.",
    "section": "Array:append",
    "text": "Array:append\nExample\nlocal a = Array:range(1,3)\nputln(\"Original:                %t\", a)\n1putln(\"Appended 4,5,6:          %t\", a:append(4,5,6))\nlocal b = Array{7,8,9}\n2putln(\"Appended %t:    %t\", b, a:append(b))\nlocal c = {10,11,12}\nlocal b = Array{7,8,9}\n3putln(\"Appended %t: %t\", c, a:append(c))\n\n1\n\nAppending individual elements.\n\n2\n\nAppending another Array.\n\n3\n\nAppending a table that is a Lua array but not an Array.\n\n\nOutput\nOriginal:                [ 1, 2, 3 ]\nAppended 4,5,6:          [ 1, 2, 3, 4, 5, 6 ]\n1Appended [ 7, 8, 9 ]:    [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n2Appended [ 10, 11, 12 ]: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ]\n\n1\n\nThe appended Array is unwrapped for one level.\n\n2\n\nThe appended Array is unwrapped for one level."
  },
  {
    "objectID": "pages/Array/change.html#arraysort",
    "href": "pages/Array/change.html#arraysort",
    "title": "Lulu Arrays — Changing Elements etc.",
    "section": "Array:sort",
    "text": "Array:sort\nExample: Using the default comparator\nlocal arr = Array:range(50,10, -10)\narr:append('mary', 'elizabeth', 'joy')\nputln(\"array:  %t\", arr)\n1putln(\"sorted: %t\", arr:sort())\n\n1\n\nWe sort the array using the default comparator.\n\n\nThe gives the output:\narray:  [ 50, 40, 30, 20, 10, \"mary\", \"elizabeth\", \"joy\" ]\n1sorted: [ 10, 20, 30, 40, 50, \"elizabeth\", \"joy\", \"mary\" ]\n\n1\n\nThe elements are sorted first by type and then alphabetically.\n\n\nExample: Using a custom comparator The comparator can be a Lua function, a string lambda, or a table with an appropriate __call metamethod. In any case, two values v1 and v2 will be passed and should return true if v1 is to come before v2.\nlocal arr = Array:range(10,50,10)\nputln(\"array:  %t\", arr)\n1putln(\"sorted: %t\", arr:sort(\"&gt;\"))\n\n1\n\nHere, we sort the array into reverse order as the more significant items come first.\n\n\nThe gives the output:\narray:  [ 10, 20, 30, 40, 50 ]\nsorted: [ 50, 40, 30, 20, 10 ]"
  },
  {
    "objectID": "pages/Array/change.html#arrayshuffle",
    "href": "pages/Array/change.html#arrayshuffle",
    "title": "Lulu Arrays — Changing Elements etc.",
    "section": "Array:shuffle",
    "text": "Array:shuffle\nThis method randomly shuffles the items in an array.\nExample: Dealing four hands for a game of Bridge Bridge is a card game using a standard deck of 52 cards. The four players, south, west, north, and east, each get 13 cards.\n-- A deck of cards in Bridge order\nlocal deck = Array {\n    'C2','C3','C4','C5','C6','C7','C8','C9','CT','CJ','CQ','CK','CA',   -- Clubs from the 2 to the Ace\n    'D2','D3','D4','D5','D6','D7','D8','D9','DT','DJ','DQ','DK','DA',   -- Diamonds from the 2 to the Ace\n    'H2','H3','H4','H5','H6','H7','H8','H9','HT','HJ','HQ','HK','HA',   -- Hearts from the 2 to the Ace\n    'S2','S3','S4','S5','S6','S7','S8','S9','ST','SJ','SQ','SK','SA'    -- Spades from the 2 to the Ace\n}\n\n-- Shuffled version of the deck\nlocal shuffled = deck:shuffle()\n\n-- Deal out 13 cards to each player:\n1local south  = shuffled:take(13)\nlocal west   = shuffled:take(14,26)\nlocal north  = shuffled:take(27,39)\nlocal east   = shuffled:take(40,52)\n\n-- Look at what we got:\nputln(\"south: %t\", south)\nputln(\"west:  %t\", west)\nputln(\"north: %t\", north)\nputln(\"east:  %t\", east)\n\n1\n\nSee the Array:take method for details.\n\n\nThe actual cards dealt vary from run to run, but here is a sample output:\nsouth: [ \"C2\", \"D7\", \"SJ\", \"C3\", \"CJ\", \"H7\", \"H8\", \"SK\", \"S5\", \"C5\", \"S2\", \"D9\", \"D5\" ]\nwest:  [ \"H5\", \"DJ\", \"HJ\", \"D8\", \"SA\", \"SQ\", \"HK\", \"S6\", \"DT\", \"DQ\", \"C4\", \"C6\", \"H3\" ]\nnorth: [ \"CA\", \"ST\", \"CT\", \"D6\", \"DK\", \"HA\", \"D3\", \"D2\", \"S4\", \"H9\", \"S9\", \"H4\", \"C7\" ]\neast:  [ \"C9\", \"HQ\", \"S7\", \"CK\", \"HT\", \"CQ\", \"S8\", \"DA\", \"C8\", \"D4\", \"H2\", \"S3\", \"H6\" ]"
  },
  {
    "objectID": "pages/Array/change.html#arrayreverse",
    "href": "pages/Array/change.html#arrayreverse",
    "title": "Lulu Arrays — Changing Elements etc.",
    "section": "Array:reverse",
    "text": "Array:reverse\nThis method reverses the order of the elements of an array.\nFor example:\nlocal arr = Array:range(10,50,10)\nputln(\"Original: %t\", arr)\nputln(\"Reversed: %t\", arr:reverse())\nOutputs:\nOriginal: [ 10, 20, 30, 40, 50 ]\nReversed: [ 50, 40, 30, 20, 10 ]\n\n    \n     \n    \n    \nThis method works *in place, moving the elements in the input array to their new locations."
  },
  {
    "objectID": "pages/Array/change.html#arrayreversed",
    "href": "pages/Array/change.html#arrayreversed",
    "title": "Lulu Arrays — Changing Elements etc.",
    "section": "Array:reversed",
    "text": "Array:reversed\nThis method returns a new Array with the elements of self in reverse order. Unlike all the other methods on this page self is not changed by tbe call.\nFor example:\nlocal a = Array:range(10,50,10)\nlocal b = a:reversed()\nputln(\"Original: %t\", a)\nputln(\"Reversed: %t\", b)\nOutputs:\nOriginal: [ 10, 20, 30, 40, 50 ]\nReversed: [ 50, 40, 30, 20, 10 ]"
  },
  {
    "objectID": "pages/Array/change.html#arraydelete",
    "href": "pages/Array/change.html#arraydelete",
    "title": "Lulu Arrays — Changing Elements etc.",
    "section": "Array:delete",
    "text": "Array:delete\nEfficiently deletes the elements of an array from index m to index n inclusive. Negative m and n count back from the end of the array. If there is no n argument, we delete the first or final m elements. The no-argument call arr:delete() deletes the first element in arr.\n\n    \n     \n    \n    \nThis method does not use table.remove.\n\nIt is much more efficient than the equivalent code:\nfor i = m, n do\n    table.remove(self, m)\nend\nExample:\nputln(\"Array:range(1,10):delete(4):    %t\", Array:range(1, 10):delete(4))\nputln(\"Array:range(1,10):delete(-4):   %t\", Array:range(1, 10):delete(-4))\nputln(\"Array:range(1,10):delete(4, 7): %t\", Array:range(1, 10):delete(4, 7))\nputln(\"Array:range(1,10):delete():     %t\", Array:range(1, 10):delete())\nOutput:\nArray:range(1,10):delete(4):    [ 5, 6, 7, 8, 9, 10 ]\nArray:range(1,10):delete(-4):   [ 1, 2, 3, 4, 5, 6 ]\nArray:range(1,10):delete(4, 7): [ 1, 2, 3, 8, 9, 10 ]\nArray:range(1,10):delete():     [ 2, 3, 4, 5, 6, 7, 8, 9, 10 ]"
  },
  {
    "objectID": "pages/Array/change.html#arraydelete_if",
    "href": "pages/Array/change.html#arraydelete_if",
    "title": "Lulu Arrays — Changing Elements etc.",
    "section": "Array:delete_if",
    "text": "Array:delete_if\nEfficiently deletes any element of an array that pass a predicate test.\nExample:\nlocal arr = Array:range(1, 10)\narr:delete_if(function(x) return x % 2 == 0 end)\nputln(\"Array: %t\", arr)\nOutput:\nArray: [ 1, 3, 5, 7, 9 ]"
  },
  {
    "objectID": "pages/Array/change.html#arraykeep",
    "href": "pages/Array/change.html#arraykeep",
    "title": "Lulu Arrays — Changing Elements etc.",
    "section": "Array:keep",
    "text": "Array:keep\nEfficiently deletes all elements of an array except those from index m to index n inclusive. Negative m and n count back from the end of the array. If there is no n argument, we keep the first or final m elements. The no-argument call arr:delete() deletes the final element in arr.\nExample:\nputln(\"Array:range(1,10):keep(4):    %t\", Array:range(1, 10):keep(4))\nputln(\"Array:range(1,10):keep(-4):   %t\", Array:range(1, 10):keep(-4))\nputln(\"Array:range(1,10):keep(4, 7): %t\", Array:range(1, 10):keep(4, 7))\nputln(\"Array:range(1,10):keep():     %t\", Array:range(1, 10):keep())\nOutput:\nArray:range(1,10):keep(4):    [ 1, 2, 3, 4 ]\nArray:range(1,10):keep(-4):   [ 7, 8, 9, 10 ]\nArray:range(1,10):keep(4, 7): [ 4, 5, 6, 7 ]\nArray:range(1,10):keep():     [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]"
  },
  {
    "objectID": "pages/Array/change.html#arraykeep_if",
    "href": "pages/Array/change.html#arraykeep_if",
    "title": "Lulu Arrays — Changing Elements etc.",
    "section": "Array:keep_if",
    "text": "Array:keep_if\nEfficiently deletes all elements of an array except those that pass a predicate test.\nExample:\nlocal arr = Array:range(1, 10)\narr:keep_if('_ % 2 == 0')\nputln(\"Array: %t\", arr)\nOutput:\nArray: [ 2, 4, 6, 8, 10 ]"
  },
  {
    "objectID": "pages/Array/change.html#predicate-functions",
    "href": "pages/Array/change.html#predicate-functions",
    "title": "Lulu Arrays — Changing Elements etc.",
    "section": "Predicate Functions",
    "text": "Predicate Functions\nThe predicate function in delete_if and keep_if will be called as predicate(arr[i],...) for each element arr[i] in the array arr. It should return true if that element is considered to have passed the test.\nThe function is passed any extra ... arguments that were given to the original class method call. Of course, it may ignore those.\nThe “function” can come in several forms. For example, the predicate to test for positivity can be written as:\n\narr:keep_if(function(x) return x % 2 == 0 end)\narr:keep_if(\"_ % 2 == 0\")\narr:keep_if(\"|v| v % 2 == 0\")\nYou can pass a “table” that is callable, i.e., it has a __call() metamethod that does the appropriate thing.\n\nThere is more detail in the documentation for the lulu.callable module."
  },
  {
    "objectID": "pages/Array/change.html#see-also",
    "href": "pages/Array/change.html#see-also",
    "title": "Lulu Arrays — Changing Elements etc.",
    "section": "See Also",
    "text": "See Also\nArray:range  Array:transform  Array.__concat  Array:flatten  Array:take  Array:drop  Array:drop_duplicates  lulu.callable"
  },
  {
    "objectID": "pages/Array/index.html",
    "href": "pages/Array/index.html",
    "title": "Lulu — Array Class",
    "section": "",
    "text": "Lua arrays are tables where the keys are successive integers starting at 1.  Internally, Lua treats those tables very efficiently.\nThe lulu.Array module provides a specific class for this commonest of data structures.\nYou can import the class with the line:\nlocal Array = require('lulu.Array')\nThe class has a rich interface with quite a few methods. In practice, each belongs to a functional group, and we first list them by those groupings. The method names within any group follow a consistent scheme.\nThe complete list of all the methods is also available in alphabetic order.",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/index.html#introduction",
    "href": "pages/Array/index.html#introduction",
    "title": "Lulu — Array Class",
    "section": "",
    "text": "Lua arrays are tables where the keys are successive integers starting at 1.  Internally, Lua treats those tables very efficiently.\nThe lulu.Array module provides a specific class for this commonest of data structures.\nYou can import the class with the line:\nlocal Array = require('lulu.Array')\nThe class has a rich interface with quite a few methods. In practice, each belongs to a functional group, and we first list them by those groupings. The method names within any group follow a consistent scheme.\nThe complete list of all the methods is also available in alphabetic order.",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/index.html#metamethods-etc.",
    "href": "pages/Array/index.html#metamethods-etc.",
    "title": "Lulu — Array Class",
    "section": "Metamethods etc.",
    "text": "Metamethods etc.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nArray.__call\nMetamethod that points Array(...) to Array:new.\n\n\nArray.__concat\nMetamethod that joins two Arrays using the Lua notation a .. b.\n\n\nArray:.__eq\nMetamethod that checks for deep equality between two Arrays using a == b.\n\n\nArray.__name\nA piece of string metadata that is set to “Array” in the base class.\n\n\nArray.__tostring\nMetamethod that points tostring(a) to {Array.stringify}.\n\n\nArray:is_instance\nChecks whether the argument is an instance of the Array class or a subclass.\n\n\nArray:name\nReturns the name of the class or subclass from Array.__name.",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/index.html#constructors",
    "href": "pages/Array/index.html#constructors",
    "title": "Lulu — Array Class",
    "section": "Constructors",
    "text": "Constructors\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nArray:new\nCreate an Array instance in various ways.\n\n\nArray:new_instance\nCreate a new instance of the same class as the calling Array.\n\n\nArray:rep\nCreate an Array with a specified size and repeated initial value.\n\n\nArray:range\nCreate an Array as a range of numbers.\n\n\nArray:subclass\nCreate a subclass of Array or a sub-subclass etc.",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/index.html#copying-comparing",
    "href": "pages/Array/index.html#copying-comparing",
    "title": "Lulu — Array Class",
    "section": "Copying & Comparing",
    "text": "Copying & Comparing\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nArray:clone\nCreate a shallow copy of an Array.\n\n\nArray:copy\nCreate a deep copy of an Array.\n\n\nArray:eq\nReturns true if an Array is deeply equal to another Array.",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/index.html#queries",
    "href": "pages/Array/index.html#queries",
    "title": "Lulu — Array Class",
    "section": "Queries",
    "text": "Queries\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nArray:size\nReturns the number of elements in an Array.\n\n\nArray:is_empty\nReturns true if an Array is empty.\n\n\nArray:first\nReturns the first element or a default value if an Array is empty.\n\n\nArray:final\nReturns the final element or a default value if an Array is empty.\n\n\nArray:at\nReturns a specific Array element.\n\n\nArray:random\nReturns a random value from an Array.\n\n\nArray:extreme\nReturns the index & value of the “extreme” element according to a comparator function.\n\n\nArray:max\nReturns the index & value of the “maximum” element.\n\n\nArray:min\nReturns the index & value of the “minimum” element.",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/index.html#element-types",
    "href": "pages/Array/index.html#element-types",
    "title": "Lulu — Array Class",
    "section": "Element Types",
    "text": "Element Types\nWe often are interested in arrays where the elements are all of one type or of some specific type.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nArray:is_array_of\nAre all the elements some specific type?\n\n\nArray:is_array_of_numbers\nReturns true if the elements are all numbers.\n\n\nArray:is_array_of_one_type\nReturns true if all the elements have the same type.\n\n\nArray:is_array_of_strings\nReturns true if the elements are all strings.\n\n\n\n\n\n    \n     \n    \n    \nIn these methods, the element type is determined by the lulu.types method which slightly expands on the Lua standard type function.",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/index.html#changing",
    "href": "pages/Array/index.html#changing",
    "title": "Lulu — Array Class",
    "section": "Changing",
    "text": "Changing\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nArray:clear\nClears an Array in place from an optional start index.\n\n\nArray:push\nAdd a value to the end of an Array.\n\n\nArray:pop\nRemove the value from the end of and Array & return the value removed.\n\n\nArray:insert\nInsert a value at a given position.\n\n\nArray:remove\nRemove the value at position pos & return the value removed.\n\n\nArray:append\nAppend the passed arguments to the end of an Array.\n\n\nArray:sort\nSorts an Array in place.\n\n\nArray:shuffle\nShuffles an Array in place.\n\n\nArray:reverse\nReverses the elements of an Array in place.\n\n\nArray:reversed\nReturns a new Array that has as Array’s elements in reverse order.\n\n\nArray:delete\nEfficiently deletes the a range of elements from an Array.\n\n\nArray:delete_if\nEfficiently deletes all elements from an Array that pass a predicate test.\n\n\nArray:keep\nEfficiently deletes all values from an Array except those in a range.\n\n\nArray:keep_if\nEfficiently deletes all values from an Array except those that pass a predicate test.",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/index.html#sub-arrays",
    "href": "pages/Array/index.html#sub-arrays",
    "title": "Lulu — Array Class",
    "section": "Sub-Arrays",
    "text": "Sub-Arrays\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nArray:drop\nReturns a new Array that is a copy with a range of elements removed.\n\n\nArray:drop_duplicates\nReturns a new Array that contains only the non-duplicated elements.\n\n\nArray:drop_if\nReturns a new Array that is a copy without any elements that pass a predicate test.\n\n\nArray:take\nReturns a new Array that is a sub-array of this one.\n\n\nArray:take_if\nReturns a new Array that is a copy of the elements that pass a predicate test.\n\n\nArray:most\nReturns a new Array that is a copy of this one without the final element.\n\n\nArray:rest\nReturns a new Array that is a copy of this one without the first element.\n\n\n\n\nThese methods typically return a reference to self to allow for method chaining.",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/index.html#searches",
    "href": "pages/Array/index.html#searches",
    "title": "Lulu — Array Class",
    "section": "Searches",
    "text": "Searches\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nArray:all\nChecks whether all elements in an Array pass a predicate test.\n\n\nArray:any\nChecks whether any element in an Array pass a predicate test.\n\n\nArray:none\nChecks whether no elements in an Array pass a predicate test.\n\n\nArray:find\nReturns the index of the first element which matches a value or nil if the search fails.\n\n\nArray:find_if\nReturns the index of the first element that satisfies a predicate function or nil if the search fails.\n\n\nArray:find_reverse\nReturns the index of the first element which matches a value or nil if the search fails. Search is done in reverse from the end of the Array.\n\n\nArray:find_if_reverse\nReturns the index of the first element that satisfies a predicate function or nil if the search fails. Search is done in reverse from the end of the Array.",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/index.html#counts-etc.",
    "href": "pages/Array/index.html#counts-etc.",
    "title": "Lulu — Array Class",
    "section": "Counts etc.",
    "text": "Counts etc.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nArray:counts\nReturns a map of the values in an Array to the number of times they occur.\n\n\nArray:to_map\nReturns a map of the values in an Array to their indices.\n\n\nArray:to_set\nCreates a set from the elements in an Array.",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/index.html#folding-and-reducing",
    "href": "pages/Array/index.html#folding-and-reducing",
    "title": "Lulu — Array Class",
    "section": "Folding and Reducing",
    "text": "Folding and Reducing\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nArray:fold\nReturns a new Array which is the result of “folding” a function over an Array.\n\n\nArray:reduce\nReduce an Array to a single value by applying a function to each element and accumulating the result.",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/index.html#mapping",
    "href": "pages/Array/index.html#mapping",
    "title": "Lulu — Array Class",
    "section": "Mapping",
    "text": "Mapping\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nArray:map\nReturns a new Array which is the result of applying a function to each element.\n\n\nArray:transform\nTransform an Array in place by applying a function to each element",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/index.html#combining",
    "href": "pages/Array/index.html#combining",
    "title": "Lulu — Array Class",
    "section": "Combining",
    "text": "Combining\nMethods to find values in common between arrays etc. These methods only consider the values of array elements when considering commonality and differences.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nArray:union\nReturns the union of two or more Arrays.  Elements are identified by their values only.\n\n\nArray:intersection\nReturns the intersection of two or more Arrays.  Elements are identified by their values only.\n\n\nArray:difference\nReturns the difference between two Arrays.  Elements are identified by their values only.  Optionally can return the symmetric difference.",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/index.html#stringifying",
    "href": "pages/Array/index.html#stringifying",
    "title": "Lulu — Array Class",
    "section": "Stringifying",
    "text": "Stringifying\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nArray:inline\nReturns a one-line string representation of an Array.\n\n\nArray:pretty\nReturns a “pretty” multiline string representation of an Array.\n\n\nArray:alt\nReturns an alternate “pretty” multiline string representation of an Array.\n\n\nArray.__tostring\nReturns a string representation of this Array.",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/index.html#miscellaneous",
    "href": "pages/Array/index.html#miscellaneous",
    "title": "Lulu — Array Class",
    "section": "Miscellaneous",
    "text": "Miscellaneous\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nArray:flatten\nReturns a new Array which is a flattened version of this one.\n\n\nArray:zip\nReturns a new Array formed by zipping this one with other arguments.",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/index.html#all-methods",
    "href": "pages/Array/index.html#all-methods",
    "title": "Lulu — Array Class",
    "section": "All Methods",
    "text": "All Methods\nHere is a table of all the class methods in alphabetical order:\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nArray.__call\nMetamethod that points Array(...) to Array:new.\n\n\nArray.__concat\nMetamethod that joins two Arrays using the Lua notation a .. b.\n\n\nArray:.__eq\nMetamethod that checks for deep equality between two Arrays using a == b.\n\n\nArray.__name\nA piece of string metadata that is set to “Array” in the base class.\n\n\nArray.__tostring\nMetamethod that points tostring(a) to {Array.stringify}.\n\n\nArray:all\nChecks whether all elements in an Array pass a predicate test.\n\n\nArray:alt\nReturns an alternate “pretty” multiline string representation of an Array.\n\n\nArray:any\nChecks whether any element in an Array pass a predicate test.\n\n\nArray:append\nAppend the passed arguments to the end of an Array.\n\n\nArray:at\nReturns a specific Array element.\n\n\nArray:clear\nClears an Array in place from an optional start index.\n\n\nArray:clone\nCreate a shallow copy of an Array.\n\n\nArray:copy\nCreate a deep copy of an Array.\n\n\nArray:counts\nReturns a map of the values in an Array to the number of times they occur.\n\n\nArray:delete\nEfficiently deletes the a range of elements from an Array.\n\n\nArray:delete_if\nEfficiently deletes all elements from an Array that pass a predicate test.\n\n\nArray:difference\nReturns the difference between two Arrays.\n\n\nArray:drop\nReturns a new Array that is a copy with a range of elements removed.\n\n\nArray:drop_duplicates\nReturns a new Array that contains only the non-duplicated elements.\n\n\nArray:drop_if\nReturns a new Array that is a copy without any elements that pass a predicate test.\n\n\nArray:eq\nReturns true if an Array is deeply equal to another Array.\n\n\nArray:extreme\nReturns the index & value of the “extreme” element according to a comparator function.\n\n\nArray:final\nReturns the final element or a default value if an Array is empty.\n\n\nArray:find\nReturns the index of the first element which matches a value or nil if the search fails.\n\n\nArray:find_if\nReturns the index of the first element that satisfies a predicate function or nil if the search fails.\n\n\nArray:find_if_reverse\nReturns the index of the first element that satisfies a predicate function or nil if the search fails. Search is done in reverse from the end of the Array.\n\n\nArray:find_reverse\nReturns the index of the first element which matches a value or nil if the search fails. Search is done in reverse from the end of the Array.\n\n\nArray:first\nReturns the first element or a default value if an Array is empty.\n\n\nArray:flatten\nReturns a new Array which is a flattened version of this one.\n\n\nArray:fold\nReturns a new Array which is the result of “folding” a function over an Array.\n\n\nArray:inline\nReturns a one-line string representation of an Array.\n\n\nArray:inline_json\nReturns a one-line JSON string representation of an Array.\n\n\nArray:insert\nInsert a value at a given position.\n\n\nArray:intersection\nReturns the intersection of two or more Arrays.  Elements are identified by their values only.\n\n\nArray:is_array_of\nAre all the elements some specific type?\n\n\nArray:is_array_of_numbers\nReturns true if the elements are all numbers.\n\n\nArray:is_array_of_one_type\nReturns true if all the elements have the same type.\n\n\nArray:is_array_of_strings\nReturns true if the elements are all strings.\n\n\nArray:is_empty\nReturns true is an Array is empty.\n\n\nArray:is_instance\nChecks whether the argument is an instance of the Array class or a subclass.\n\n\nArray:json\nReturns a JSON string representation of an Array.\n\n\nArray:keep\nEfficiently deletes all values from an Array except those in a range.\n\n\nArray:keep_if\nEfficiently deletes all values from an Array except those that pass a predicate test.\n\n\nArray:map\nReturns a new Array which is the result of applying a function to each element.\n\n\nArray:max\nReturns the index & value of the “maximum” element.\n\n\nArray:min\nReturns the index & value of the “minimum” element.\n\n\nArray:most\nReturns a new Array that is a copy of this one without the final element.\n\n\nArray:name\nReturns the name of the class or subclass from Array.__name.\n\n\nArray:new\nCreate an Array instance in various ways.\n\n\nArray:new_instance\nCreate a new instance of the same class as the calling Array.\n\n\nArray:none\nChecks whether no elements in an Array pass a predicate test.\n\n\nArray:pop\nRemove the value from the end of and Array & return the value removed.\n\n\nArray:pretty\nReturns a “pretty” multiline string representation of an Array.\n\n\nArray:push\nAdd a value to the end of an Array.\n\n\nArray:random\nReturns a random value from an Array.\n\n\nArray:range\nCreate an Array as a range of numbers.\n\n\nArray:reduce\nReduce an Array to a single value by applying a function to each element and accumulating the result.\n\n\nArray:remove\nRemove the value at position pos & return the value removed.\n\n\nArray:rep\nCreate an Array with a specified size and repeated initial value.\n\n\nArray:reverse\nReverses the elements of an Array in place.\n\n\nArray:reversed\nReturns a new Array that has as Array’s elements in reverse order.\n\n\nArray:rest\nReturns a new Array that is a copy of this one without the first element.\n\n\nArray:shuffle\nShuffles an Array in place.\n\n\nArray:size\nReturns the number of elements in an Array.\n\n\nArray:sort\nSorts an Array in place.\n\n\nArray:subclass\nCreate a subclass of Array or a sub-subclass etc.\n\n\nArray:take\nReturns a new Array that is a sub-array of this one.\n\n\nArray:take_if\nReturns a new Array that is a copy of the elements that pass a predicate test.\n\n\nArray:to_map\nReturns a map of the values in an Array to their indices.\n\n\nArray:to_set\nCreates a set from the elements in an Array.\n\n\nArray:transform\nTransform an Array in place by applying a function to each element\n\n\nArray:union\nReturns the union of two or more Arrays.\n\n\nArray:zip\nReturns a new Array formed by zipping this one with other arguments.",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/index.html#see-also",
    "href": "pages/Array/index.html#see-also",
    "title": "Lulu — Array Class",
    "section": "See Also",
    "text": "See Also\nlulu.table  lulu.types  lulu.scribe",
    "crumbs": [
      "Home",
      "The Array Class"
    ]
  },
  {
    "objectID": "pages/Array/zip.html",
    "href": "pages/Array/zip.html",
    "title": "Lulu Arrays – Zipping Collections",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you can use “zip” to combine two or more arrays.\nArray:zip(...)  Returns a new Array formed by zipping self with other arguments.\nSimplest Example:\nlocal a1, a2 = Array{1,2,3}, Array{4,5,6}\n1putln(\"%t:zip(%t) = %t\", a1, a2, a1:zip(a2))\n\n1\n\nWe use {format.putln} for formatted printing.\n\n\nOutputs:\n[ 1, 2, 3 ]:zip([ 4, 5, 6 ]) = [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\nIn that example a1 must be an Array instance but a2 could be a plain Lua array:\n1local a1, a2 = Array{1,2,3}, {4,5,6}\nputln(\"%t:zip(%t) = %t\", a1, a2, a1:zip(a2))\n\n1\n\na2 is now a plain Lua array.\n\n\nOutputs:\n[ 1, 2, 3 ]:zip([ 4, 5, 6 ]) = [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\nMultiple Arguments of the Same Length:\nlocal a1, a2, a3 = Array{1,2,3}, {4,5,6}, {7,8,9}\nputln(\"%t:zip(%t,%t) = %t\", a1, a2, a3, a1:zip(a2,a3))\nOutputs:\n[ 1, 2, 3 ]:zip([ 4, 5, 6 ],[ 7, 8, 9 ]) = [ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]"
  },
  {
    "objectID": "pages/Array/zip.html#introduction",
    "href": "pages/Array/zip.html#introduction",
    "title": "Lulu Arrays – Zipping Collections",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you can use “zip” to combine two or more arrays.\nArray:zip(...)  Returns a new Array formed by zipping self with other arguments.\nSimplest Example:\nlocal a1, a2 = Array{1,2,3}, Array{4,5,6}\n1putln(\"%t:zip(%t) = %t\", a1, a2, a1:zip(a2))\n\n1\n\nWe use {format.putln} for formatted printing.\n\n\nOutputs:\n[ 1, 2, 3 ]:zip([ 4, 5, 6 ]) = [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\nIn that example a1 must be an Array instance but a2 could be a plain Lua array:\n1local a1, a2 = Array{1,2,3}, {4,5,6}\nputln(\"%t:zip(%t) = %t\", a1, a2, a1:zip(a2))\n\n1\n\na2 is now a plain Lua array.\n\n\nOutputs:\n[ 1, 2, 3 ]:zip([ 4, 5, 6 ]) = [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\nMultiple Arguments of the Same Length:\nlocal a1, a2, a3 = Array{1,2,3}, {4,5,6}, {7,8,9}\nputln(\"%t:zip(%t,%t) = %t\", a1, a2, a3, a1:zip(a2,a3))\nOutputs:\n[ 1, 2, 3 ]:zip([ 4, 5, 6 ],[ 7, 8, 9 ]) = [ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]"
  },
  {
    "objectID": "pages/Array/zip.html#unequal-lengths",
    "href": "pages/Array/zip.html#unequal-lengths",
    "title": "Lulu Arrays – Zipping Collections",
    "section": "Unequal Lengths",
    "text": "Unequal Lengths\nThe method also handles arguments that are not all the same length.\nThe number of “rows” in the return value is always the same as the number of elements in the longest argument. If the input arrays are of different lengths, we cycle through the shorter arrays to fill the gaps.\nSimplest Example:\nlocal a1, a2 = Array{1,2,3}, {4,5}\nputln(\"%t:zip(%t) = %t\", a1, a2, a1:zip(a2))\nOutputs:\n[ 1, 2, 3 ]:zip([ 4, 5 ]) = [ [ 1, 4 ], [ 2, 5 ], [ 3, 4 ] ]\nMultiple Argument Example:\nlocal a1, a2, a3 = Array{1,2}, {4,5}, {7,8,9}\nputln(\"%t:zip(%t, %t) = %t\", a1, a2, a3, a1:zip(a2,a3))\nOutputs:\n[ 1, 2 ]:zip([ 4, 5 ], [ 7, 8, 9 ]) = [ [ 7, 4, 1 ], [ 8, 5, 2 ], [ 9, 4, 1 ] ]"
  },
  {
    "objectID": "pages/Array/zip.html#scalar-arguments",
    "href": "pages/Array/zip.html#scalar-arguments",
    "title": "Lulu Arrays – Zipping Collections",
    "section": "Scalar Arguments",
    "text": "Scalar Arguments\nYou can also pass non-table arguments, which are simply treated as single-element arrays in this function.\nExample:\nlocal a1, a2, a3 = Array{1,2,3}, 4, 5\nputln(\"%t:zip(%d, %d) = %t\", a1, a2, a3, a1:zip(a2, a3))\nOutputs:\n[ 1, 2, 3 ]:zip(4, 5) = [ [ 1, 4, 5 ], [ 2, 4, 5 ], [ 3, 4, 5 ] ]"
  },
  {
    "objectID": "pages/Array/zip.html#see-also",
    "href": "pages/Array/zip.html#see-also",
    "title": "Lulu Arrays – Zipping Collections",
    "section": "See Also",
    "text": "See Also\nArray:flatten"
  },
  {
    "objectID": "pages/Array/fold.html",
    "href": "pages/Array/fold.html",
    "title": "Lulu Arrays — Folding and Reducing",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you have access to the following methods:\nArray:fold(f, x)  Returns a new array, which is the result of “folding” a function over self.  The x argument is optional and defaults to self[1].\nArray:reduce(f, x)  Reduce self to a single value by applying a function to each element and accumulating the result.  The x argument is optional and defaults to self[1]."
  },
  {
    "objectID": "pages/Array/fold.html#introduction",
    "href": "pages/Array/fold.html#introduction",
    "title": "Lulu Arrays — Folding and Reducing",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you have access to the following methods:\nArray:fold(f, x)  Returns a new array, which is the result of “folding” a function over self.  The x argument is optional and defaults to self[1].\nArray:reduce(f, x)  Reduce self to a single value by applying a function to each element and accumulating the result.  The x argument is optional and defaults to self[1]."
  },
  {
    "objectID": "pages/Array/fold.html#arrayfold",
    "href": "pages/Array/fold.html#arrayfold",
    "title": "Lulu Arrays — Folding and Reducing",
    "section": "Array:fold",
    "text": "Array:fold\nSuppose that arr = Array{a,b,c, ...} then arr:fold(f,x) returns [ x, f(x,a), f(f(x,a),b), ... ].\nIf the x argument is missing, then arr:fold(f) returns [ a, f(a,b), f(f(a,b),c), ... ].\n\n    \n     \n    \n    \nIf you pass an x argument, the returned array will be of size #self+1; otherwise, it will have size #self.\n\nExample:\n1local arr = Array:range(1,10)\n2putln(\"array: %t\", arr)\n3putln(\"sums:  %t\", arr:fold(\"+\", 0))\n4putln(\"sums:  %t\", arr:fold(\"+\"))\n\n1\n\nSee the Array:range method for the details.\n\n2\n\nThe examples on this page use putln from lulu.scribe for formatted printing.\n\n3\n\nRunning sum totals starting from 0.\n\n4\n\nRunning sums without the zero value isn’t helpful in this case.\n\n\nOutput:\narray: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]\nsums:  [ 0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55 ]\nsums:  [ 1, 3, 6, 10, 15, 21, 28, 36, 45, 55 ]"
  },
  {
    "objectID": "pages/Array/fold.html#functions",
    "href": "pages/Array/fold.html#functions",
    "title": "Lulu Arrays — Folding and Reducing",
    "section": "Functions",
    "text": "Functions\nThe function f passed to Array:fold and Array:reduce will be passed two arguments and should return a single value. If the optional x argument is missing then the first call will be f(self[1], self[2]), the next will be f((self[1], self[2]), self[3]) and so on.\nThe “function” can come in several forms. For example, if you wish to add up the elements in arr then you could form the function as follows:\n\narr:reduce(function(a,b) return a + b end, 0)\narr:reduce(\"+\", 0)\narr:reduce(\"|a,b| a + b\", 0)\nYou can pass a “table” that is callable, i.e., it has a __call() metamethod that does the appropriate thing.\n\nThere is more detail on the second and third options in the documentation for the lulu.callable module."
  },
  {
    "objectID": "pages/Array/fold.html#see-also",
    "href": "pages/Array/fold.html#see-also",
    "title": "Lulu Arrays — Folding and Reducing",
    "section": "See Also",
    "text": "See Also\nArray:range  Array:transform  Array:map  lulu.callable"
  },
  {
    "objectID": "pages/Array/map.html",
    "href": "pages/Array/map.html",
    "title": "Lulu Arrays — Mapping & Transforming",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you have access to the following methods:\nArray:map(fun,...)  Returns a new Array, which results from applying fun to each value in self.\nArray:transform(fun,...)  Transform an Array in place by applying fun to each top-level value. This method returns the transformed self and is ready for further processing."
  },
  {
    "objectID": "pages/Array/map.html#introduction",
    "href": "pages/Array/map.html#introduction",
    "title": "Lulu Arrays — Mapping & Transforming",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nThen, you have access to the following methods:\nArray:map(fun,...)  Returns a new Array, which results from applying fun to each value in self.\nArray:transform(fun,...)  Transform an Array in place by applying fun to each top-level value. This method returns the transformed self and is ready for further processing."
  },
  {
    "objectID": "pages/Array/map.html#arraymap",
    "href": "pages/Array/map.html#arraymap",
    "title": "Lulu Arrays — Mapping & Transforming",
    "section": "Array:map",
    "text": "Array:map\nClassic “functional” method that creates a new table by applying fun to each value in self.\nIn this implementation, the function also passes any extra ... arguments in the call to Array:map(fun,...).\nIf the returned Array is the result, then for each index k, we set:\nresult[k] = fun(self[k],...)\nOf course, fun may ignore those extra arguments entirely, and Lua is happy to call a function with multiple arguments, even if it only uses the first one.\nExample:\nlocal lower = Array{'warning', 'notice', 'hint'}\nlocal upper = lower:map(string.upper)\n1putln(\"lower: %t\", lower)\nputln(\"upper: %t\", upper)\n\n1\n\nThe examples on this page use putln from lulu.scribe for formatted printing.\n\n\nOutput:\nlower: [\"warning\", \"notice\", \"hint\"]\n1upper: [\"WARNING\", \"NOTICE\", \"HINT\"]\n\n1\n\nWe mapped the Lua standard string.upper(...) method over every value in the lower array."
  },
  {
    "objectID": "pages/Array/map.html#arraytransform",
    "href": "pages/Array/map.html#arraytransform",
    "title": "Lulu Arrays — Mapping & Transforming",
    "section": "Array:transform",
    "text": "Array:transform\nThis method is like map above except that it works in place, so for each index k, we set:\nself[k] = fun(self[k],...)\nExample:\nlocal admonitions = Array{'warning', 'notice', 'hint'}\nputln(\"admonitions: %t\", admonitions)\nadmonitions:transform(string.upper)\nputln(\"admonitions: %t\", admonitions)\nOutput:\nadmonitions: [\"warning\", \"notice\", \"hint\"]\nadmonitions: [\"WARNING\", \"NOTICE\", \"HINT\"]"
  },
  {
    "objectID": "pages/Array/map.html#see-also",
    "href": "pages/Array/map.html#see-also",
    "title": "Lulu Arrays — Mapping & Transforming",
    "section": "See Also",
    "text": "See Also\nlulu.callable"
  },
  {
    "objectID": "pages/Array/size.html",
    "href": "pages/Array/size.html",
    "title": "Lulu Arrays — Size",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen you have access to the following trivial size methods:\nArray:size()  Returns the number of top-level items in self.\nArray:is_empty(tbl)  Returns true if self is empty."
  },
  {
    "objectID": "pages/Array/size.html#introduction",
    "href": "pages/Array/size.html#introduction",
    "title": "Lulu Arrays — Size",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen you have access to the following trivial size methods:\nArray:size()  Returns the number of top-level items in self.\nArray:is_empty(tbl)  Returns true if self is empty."
  },
  {
    "objectID": "pages/Array/size.html#see-also",
    "href": "pages/Array/size.html#see-also",
    "title": "Lulu Arrays — Size",
    "section": "See Also",
    "text": "See Also\nArray:first  Array:final  Array:at  Array:random"
  },
  {
    "objectID": "pages/Array/max.html",
    "href": "pages/Array/max.html",
    "title": "Lulu Arrays — Maxima and Minima",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen you have access to the following methods:\nArray:extreme(comparator,...)  Returns the value and index of the “extreme” element in self according to the comparator function.\nArray:max()  Returns the value and index of the “maximum” element in self.\nArray:min()  Returns the value and index of the “minimum” element in self."
  },
  {
    "objectID": "pages/Array/max.html#introduction",
    "href": "pages/Array/max.html#introduction",
    "title": "Lulu Arrays — Maxima and Minima",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen you have access to the following methods:\nArray:extreme(comparator,...)  Returns the value and index of the “extreme” element in self according to the comparator function.\nArray:max()  Returns the value and index of the “maximum” element in self.\nArray:min()  Returns the value and index of the “minimum” element in self."
  },
  {
    "objectID": "pages/Array/max.html#arrayextreme",
    "href": "pages/Array/max.html#arrayextreme",
    "title": "Lulu Arrays — Maxima and Minima",
    "section": "Array:extreme",
    "text": "Array:extreme\nThis method uses a comparator “function”, which should take two array values, v1 and v2, as arguments and return true if v1 dominates v2. The comparator is also passed any extra ... trailing arguments from the extreme call. It is free to ignore those.\nExample: Finding the top student Suppose we have an array of exam results and want to find the top student:\nlocal results = Array{{'Mary', 78}, {'Johnny', 67}, {'Mark', 92}, {'Colette', 93}}\nlocal v, i    = results:extreme(function(a,b) return a[2] &gt; b[2] end)\nprint(\"Best record is at index\", i)\nprint(\"Congratulations \" .. v[1] .. \" you scored:\", v[2])\nOutput\nBest record is at index 4\nCongratulations Colette you scored: 93"
  },
  {
    "objectID": "pages/Array/max.html#arraymax-arraymin",
    "href": "pages/Array/max.html#arraymax-arraymin",
    "title": "Lulu Arrays — Maxima and Minima",
    "section": "Array:max & Array:min",
    "text": "Array:max & Array:min\nThe max method is the same as calling extreme with the comparator \"&gt;\".  The min method is the same as calling extreme with the comparator \"&lt;\". \nThese really do something reasonable only for Arrays with simple non-table values.\nlocal arr = Array{1,12,6,-19}\nlocal v_min, i_min = arr:min()\nlocal v_max, i_max = arr:max()\nprint(\"Minimum value\", v_min, \"occurs at index\", i_min)\nprint(\"Maximum value\", v_max, \"occurs at index\", i_max)\nOutputs:\nMinimum value -19 occurs at index 4\nMaximum value 12 occurs at index 2"
  },
  {
    "objectID": "pages/Array/max.html#comparator-functions",
    "href": "pages/Array/max.html#comparator-functions",
    "title": "Lulu Arrays — Maxima and Minima",
    "section": "Comparator Functions",
    "text": "Comparator Functions\nA custom comparator function can come in one of several forms:\n\nYou can use Lua function: i,v = results:extreme(function(a,b) return a[2] &gt; b[2] end).\nYou can use a string operator, as we show below.\nYou can use a string lambda: i,v = results:extreme(\"|v1,v2| v1[2] &gt; v2[2]\")\nYou can pass a “table” that is callable, i.e., it has a __call() metamethod that takes two items and compares them.\n\nThere is more detail on the second and third options in the documentation for the {lulu.anon} module."
  },
  {
    "objectID": "pages/Array/max.html#see-also",
    "href": "pages/Array/max.html#see-also",
    "title": "Lulu Arrays — Maxima and Minima",
    "section": "See Also",
    "text": "See Also\nArray:sort  lulu.callable"
  },
  {
    "objectID": "pages/Array/copy.html",
    "href": "pages/Array/copy.html",
    "title": "Lulu Arrays — Copying",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen you have access to the following methods to copy Arrays.\nArray:clone() Returns a shallow copy of self.\nArray:copy()  Returns a deep copy of self that can include recursive and cyclical elements."
  },
  {
    "objectID": "pages/Array/copy.html#introduction",
    "href": "pages/Array/copy.html#introduction",
    "title": "Lulu Arrays — Copying",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen you have access to the following methods to copy Arrays.\nArray:clone() Returns a shallow copy of self.\nArray:copy()  Returns a deep copy of self that can include recursive and cyclical elements."
  },
  {
    "objectID": "pages/Array/copy.html#shallow-vs.-deep-copying",
    "href": "pages/Array/copy.html#shallow-vs.-deep-copying",
    "title": "Lulu Arrays — Copying",
    "section": "Shallow vs. Deep Copying",
    "text": "Shallow vs. Deep Copying\nThe Array:clone and Array:copy methods both start by creating a new empty Array of the same type as self.\nA shallow clone then inserts copies of the top-level elements from self into that new Array.\nOn the other hand, a deep copy copies all the elements from the self argument by recursively visiting any sub-tables, sub-sub-tables, and so on.\n\n    \n     \n    \n    \nThe methods give identical results for a simple Array where the elements are not tables.\n\nExample: A Simple Array\n1local a = Array{\"Mary\", \"Sheila\", \"Fiona\"}\nlocal a_clone = a:clone()\nlocal a_copy  = a:copy()\nputln(\"a:       %t\", a)\n2putln(\"a_clone: %t\", a_clone)\nputln(\"a_copy:  %t\", a_copy)\n\n3a[1]       = \"Tom\"\na_clone[2] = \"Dick\"\na_copy[3]  = \"Harry\"\nputln(\"After changing elements:\")\nputln(\"a:       %t\", a)\n4putln(\"a_clone: %t\", a_clone)\nputln(\"a_copy:  %t\", a_copy)\n\n1\n\na is a simple Array with three elements.\n\n2\n\nWe expect that the output from a:clone() and a:copy() to be the same.\n\n3\n\nWe alter one element in each of the three Arrays.\n\n4\n\nWe check to see if the three Arrays are completely independent.\n\n\nOutput:\na:       [ \"Mary\", \"Sheila\", \"Fiona\" ]\na_clone: [ \"Mary\", \"Sheila\", \"Fiona\" ]\n1a_copy:  [ \"Mary\", \"Sheila\", \"Fiona\" ]\nAfter changing elements:\na:       [ \"Tom\", \"Sheila\", \"Fiona\" ]\na_clone: [ \"Mary\", \"Dick\", \"Fiona\" ]\n2a_copy:  [ \"Mary\", \"Sheila\", \"Harry\" ]\n\n1\n\nThe three Arrays are identical.\n\n2\n\nThe three Arrays are independent.\n\n\nExample: An Array with table elements\nlocal p1, p2 = {name = 'John', age = 25}, {name = 'Mary', age = 23}\n1local a = Array(p1, p2)\nlocal a_clone = a:clone()\nlocal a_copy  = a:copy()\nputln(\"a:       %t\", a)\nputln(\"a_clone: %t\", a_clone)\n2putln(\"a_copy:  %t\", a_copy)\n\na[1].name       = 'Tom'\na_clone[2].name = 'Fiona'\nputln(\"After changing elements in `a` and `a_clone`:\")\nputln(\"a:       %t\", a)\nputln(\"a_clone: %t\", a_clone)\n3putln(\"a_copy:  %t\", a_copy)\n\na_copy[1].name = 'Goofy'\nputln(\"After changing elements in `a_copy`:\")\nputln(\"a:       %t\", a)\nputln(\"a_clone: %t\", a_clone)\n4putln(\"a_copy:  %t\", a_copy)\n\n1\n\nIn this case a is an Array whose elements are themselves tables.\n\n2\n\nWe expect to see the same output from all of these print statements.\n\n3\n\nBut what do you expect to happen here?\n\n4\n\nAnd here?\n\n\nOutput:\n1a:       [ { age = 25, name = \"John\" }, { age = 23, name = \"Mary\" } ]\na_clone: [ { age = 25, name = \"John\" }, { age = 23, name = \"Mary\" } ]\na_copy:  [ { age = 25, name = \"John\" }, { age = 23, name = \"Mary\" } ]\nAfter changing elements in `a` and `a_clone`:\n2a:       [ { age = 25, name = \"Tom\" }, { age = 23, name = \"Fiona\" } ]\na_clone: [ { age = 25, name = \"Tom\" }, { age = 23, name = \"Fiona\" } ]\n3a_copy:  [ { age = 25, name = \"John\" }, { age = 23, name = \"Mary\" } ]\nAfter changing elements in `a_copy`:\n4a:       [ { age = 25, name = \"Tom\" }, { age = 23, name = \"Fiona\" } ]\na_clone: [ { age = 25, name = \"Tom\" }, { age = 23, name = \"Fiona\" } ]\na_copy:  [ { age = 25, name = \"Goofy\" }, { age = 23, name = \"Mary\" } ]\n\n1\n\nThe three arrays look identical.\n\n2\n\nThis shows that the elements in a_clone are really just references to the same blocks of memory used for the elements of a.\n\n3\n\nThe a_copy object is completely untouched by those changes as it is a deep copy of a.\n\n4\n\nThis reinforces the fact that a_copy is independent from a and it mirror a_clone."
  },
  {
    "objectID": "pages/Array/copy.html#see-also",
    "href": "pages/Array/copy.html#see-also",
    "title": "Lulu Arrays — Copying",
    "section": "See Also",
    "text": "See Also\nArray:eq"
  },
  {
    "objectID": "pages/Array/constructors.html",
    "href": "pages/Array/constructors.html",
    "title": "Lulu Arrays — Constructors",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen, you can create new Array instances using the following methods:\nArray:new(...) or Array(...)  Creates an Array instance by adopting an existing Lua array or by copying elements.\n\n    \n     \n    \n    \nThe function call Array(...) is a synonym for Array:new(...).\n\nArray:rep(n, value, ...)  Creates an Array instance with a specified size and repeated initial value or repeated calls to a value function.\nArray:range(start, stop, step)  Creates an array of numbers from start to stop with an optional step increment. The default step size is 1.\nArray:subclass(name, tbl)  Creates a subclass of Array or a sub-subclass etc. The name argument is optional and will be the name for the subclass. The second tbl argument is also optional and should be a table of methods to add to the subclass.\nArray:new_instance() \nReturns a new empty array instance that has the same metatable as self"
  },
  {
    "objectID": "pages/Array/constructors.html#introduction",
    "href": "pages/Array/constructors.html#introduction",
    "title": "Lulu Arrays — Constructors",
    "section": "",
    "text": "If you have imported the lulu.Array class as\nlocal Array = require 'lulu.Array'\nthen, you can create new Array instances using the following methods:\nArray:new(...) or Array(...)  Creates an Array instance by adopting an existing Lua array or by copying elements.\n\n    \n     \n    \n    \nThe function call Array(...) is a synonym for Array:new(...).\n\nArray:rep(n, value, ...)  Creates an Array instance with a specified size and repeated initial value or repeated calls to a value function.\nArray:range(start, stop, step)  Creates an array of numbers from start to stop with an optional step increment. The default step size is 1.\nArray:subclass(name, tbl)  Creates a subclass of Array or a sub-subclass etc. The name argument is optional and will be the name for the subclass. The second tbl argument is also optional and should be a table of methods to add to the subclass.\nArray:new_instance() \nReturns a new empty array instance that has the same metatable as self"
  },
  {
    "objectID": "pages/Array/constructors.html#arraynew...-or-array...",
    "href": "pages/Array/constructors.html#arraynew...-or-array...",
    "title": "Lulu Arrays — Constructors",
    "section": "Array:new(...) or Array(...)",
    "text": "Array:new(...) or Array(...)\n\nThe no argument version returns a new empty Array instance.\nIf there is a single argument which is a Lua array then it adopts that argument and converts it to an Array instance by adding an appropriate metatable.\nThe single non-array argument version returns new one element Array instance with the argument as the element.\nThe \\(n\\) argument version returns an \\(n\\)-element Array instance with those \\(n\\) elements.\n\nSimple Examples\nlocal a1 = Array()\n1putln(\"a1: %t\", a1)\n\nlocal a2 = Array(\"whatever\")\n2putln(\"a2: %t\", a2)\n\nlocal a3 = Array({1,2,3})\n3putln(\"a3: %t\", a3)\n\n4local a4 = Array{1,2,3}\nputln(\"a4: %t\", a4)\n\n1\n\nCreates the empty Array,\n\n2\n\nCreates an Array with a single element.\n\n3\n\nAdopts the array argument and converts it to an Array.\n\n4\n\nCopies the three arguments into a new Array.\n\n\nOutput\na1: []\na2: [ \"whatever\" ]\na3: [ 1, 2, 3 ]\na4: [ 1, 2, 3 ]\nThere is a subtle difference between the last two examples which we can illustrate:\nlocal t = {1,2,3}\n1local a = Array(t)\nputln(\"a: %t\", a)\n\n2t[1] = 99\n3putln(\"a: %t\", a)\n\n1\n\nWe have adopted the Lua array t as the Array a.\n\n2\n\nWe alter the first element in t.\n\n3\n\nThen look at what it does to a.\n\n\nThis outputs:\na: [ 1, 2, 3 ]\n1a: [ 99, 2, 3 ]\n\n1\n\nAs expected a[1] has changed — we adopted t so a and t point to the same region of memory."
  },
  {
    "objectID": "pages/Array/constructors.html#arrayrepn-value-...",
    "href": "pages/Array/constructors.html#arrayrepn-value-...",
    "title": "Lulu Arrays — Constructors",
    "section": "Array:rep(n, value, ...)",
    "text": "Array:rep(n, value, ...)\nThis creates an Array of size n.\nIn the simplest case value is just a constant:\nlocal a = Array:rep(3, \"Hallo\")\nputln(\"a: %s\", a)\nOutputs a: [ \"Hallo\", \"Hallo\", \"Hallo\" ].\nHowever, value can be a Lua function, a string lambda, a string operator, or callable object as described in lulu.callable. It will get called for each element i as value(i, ...) where any extra arguments to the rep method are forwarded to the value function.\nFor example:\nlocal a = Array:rep(5, \"*\", 10)\nputln(\"a: %t\", a)\nOutputs a: [ 10, 20, 30, 40, 50 ].\nThat could also be written using a full Lua function definition:\nlocal a = Array:rep(5, function(i,m) return m*i; end, 10)\nputln(\"a: %t\", a)\nOutputs a: [ 10, 20, 30, 40, 50 ]."
  },
  {
    "objectID": "pages/Array/constructors.html#arrayrangestart-stop-step",
    "href": "pages/Array/constructors.html#arrayrangestart-stop-step",
    "title": "Lulu Arrays — Constructors",
    "section": "Array:range(start, stop, step)",
    "text": "Array:range(start, stop, step)\nThis creates an Array of numbers from start to stop with an optional step increment. The default value for step is 1. The start number will be included in the array, the stop may not be depending on the value for step.\nlocal a = Array:range(1,15,4)\nputln(\"a: %t\", a)\nOutputs a: [ 1, 5, 9, 13 ] which does not include the stop value 15 because we are using a step size of 4."
  },
  {
    "objectID": "pages/Array/constructors.html#arraysubclassname-tbl",
    "href": "pages/Array/constructors.html#arraysubclassname-tbl",
    "title": "Lulu Arrays — Constructors",
    "section": "Array:subclass(name, tbl)",
    "text": "Array:subclass(name, tbl)\nThis creates a subclass of Array or a sub-subclass etc.\nThe name argument is optional. If present, it will become the name for the subclass (accessed using the Array:name method).\nThe tbl argument is also optional. If present, it can be used to pass a table of predefined methods for all instances of the subclass.\nExample\n1local CheckedArray = Array:subclass(\"CheckedArray\")\n\n2function CheckedArray:at(i)\n    if i &gt; #self then\n        local warn = require('messages').warn\n        warn(\"Index is set to %d but it should be be at most %d\", i, #self)\n        return nil\n    end\n    return self[i]\nend\n\n3local c = CheckedArray{1,2,3}\nputln(\"c is a %s with values: %s\", c:name(), c)\n\n4print(c:at(6))\n\n1\n\nCreate CheckedArray as a subclass of Array.\n\n2\n\nOverride the Array:at(i) method so that it checks the index is in bounds for a CheckedArray.\n\n3\n\nCreate an instance of CheckedArray with three elements.\n\n4\n\nTry to access element number 6.\n\n\nOutput\nc is a CheckedArray with values: [ 1, 2, 3 ]\n[WARNING] from 'at' (scratch.lua:10): Index is set to 6 but it should be be at most 3\nnil\nNote that any CheckedArray is also an Array but not vice-versa:\nlocal a, c = Array{1,2,3}, CheckedArray{1,2,3}\nputln(\"a is an Array:       %s\", Array:is_instance(a))\nputln(\"c is an Array:       %s\", Array:is_instance(c))\nputln(\"a is a CheckedArray: %s\", CheckedArray:is_instance(a))\nOutputs:\na is an Array:       true\nc is an Array:       true\na is a CheckedArray: false\nc is a CheckedArray: true"
  },
  {
    "objectID": "pages/Array/constructors.html#see-also",
    "href": "pages/Array/constructors.html#see-also",
    "title": "Lulu Arrays — Constructors",
    "section": "See Also",
    "text": "See Also\nlulu.callable"
  }
]